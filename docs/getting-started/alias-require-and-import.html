<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>alias, require, and import - Elixir</title>
  <link href="http://feeds.feedburner.com/ElixirLang" rel="alternate" title="Elixir's Blog" type="application/atom+xml" />
  <link rel="stylesheet" type="text/css" href="/css/style.css" />
  <link rel="stylesheet" type="text/css" href="/css/syntax.css" />
  <link rel="stylesheet" href="/js/icons/style.css">
  <!--[if lt IE 8]><!-->
  <link rel="stylesheet" href="/js/icons/ie7/ie7.css">
  <!--<![endif]-->
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" id="font-bitter-css" href="//fonts.googleapis.com/css?family=Bitter:400,700" type="text/css" media="screen" />
  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
  <link rel="search" type="application/opensearchdescription+xml" title="elixir-lang.org" href="/opensearch.xml" />
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-8268430-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-8268430-6');
  </script>
  <!-- Begin Jekyll SEO tag v2.2.3 -->
<meta property="og:title" content="alias, require, and import" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="https://elixir-lang.org/ja/getting-started/alias-require-and-import.html" />
<meta property="og:url" content="https://elixir-lang.org/ja/getting-started/alias-require-and-import.html" />
<script type="application/ld+json">
{"@context":"http://schema.org","@type":"WebPage","headline":"alias, require, and import","url":"https://elixir-lang.org/ja/getting-started/alias-require-and-import.html"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body class="">
  <div id="container">
    <div class="wrap">
    <div id="header">
      <div id="branding">
        <a id="site-title" href="/" title="Elixir" rel="Home">
          <img class="logo" src="/images/logo/logo.png" alt="Elixir Logo" />
        </a>
      </div>

      <div id="menu-primary" class="menu-container">
        <div class="menu">
          <ul id="menu-primary-items">
            <li class="menu-item home"><a class="spec" href="/">Home</a></li>
            <li class="menu-item install"><a class="spec" href="/install.html">Install</a></li>
            <li class="menu-item getting-started"><a class="spec" href="/getting-started/introduction.html">Guides</a></li>
            <li class="menu-item learning"><a class="spec" href="/learning.html">Learning</a></li>
            <li class="menu-item docs"><a class="spec" href="/docs.html">Docs</a></li>
            <li class="menu-item development"><a class="spec" href="/development.html">Development</a></li>
            <li class="menu-item blog"><a class="spec" href="/blog/">Blog</a></li>
            <li class="menu-item packages"><a class="spec" href="https://hex.pm/">Packages</a></li>
          </ul>
        </div>
      </div>

      <div class="clear"></div>
    </div>

    <div id="main">


<div id="sidebar-primary" class="sidebar">
  <div class="widget news">
  <h3>
    News: <a href="/blog/2018/07/25/elixir-v1-7-0-released/">Elixir v1.7 released</a>
  </h3>
</div>

<div class="widget search">
  <form method="get" id="search-form" class="search-form" action="https://www.google.com/search" onsubmit="document.getElementById('searchq').value = document.getElementById('searchfield').value + ' site:elixir-lang.org | hexdocs.pm/elixir | hexdocs.pm/mix | hexdocs.pm/eex | hexdocs.pm/logger | hexdocs.pm/iex | hexdocs.pm/ex_unit'; return true;">
		<input type="hidden" id="searchq" name="q" value="">
    <input class="search-text" type="text" placeholder="Search..." id="searchfield" aria-label="Search box">
		<input class="search-submit button" name="submit" type="submit" value="Search" aria-label="Search button">
	</form>
</div>

  <div id="mini-docu" class="widget">
  <a href="http://doc.honeypot.io/elixir-documentary-2018/?utm_source=elixir_home&utm_medium=referral">
    <div class="mini-docu-cta">
      <div class="mini-docu-copy">Watch the Elixir<br />mini-documentary!</div>
    </div>
  </a>
</div>


  
  
    <div class="widget">
     <h3 class="widget-title">Getting Started</h3>
      <ol>
        
          <li><a class="spec" href="/getting-started/introduction.html" title="はじめに">はじめに</a></li>
        
          <li><a class="spec" href="/getting-started/basic-types.html" title="基本型">基本型</a></li>
        
          <li><a class="spec" href="/getting-started/basic-operators.html" title="基本演算子">基本演算子</a></li>
        
          <li><a class="spec" href="/getting-started/pattern-matching.html" title="パターン・マッチング">パターン・マッチング</a></li>
        
          <li><a class="spec" href="/getting-started/case-cond-and-if.html" title="case, cond, if">case, cond, if</a></li>
        
          <li><a class="spec" href="/getting-started/binaries-strings-and-char-lists.html" title="バイナリ, 文字列, 文字リスト">バイナリ, 文字列, 文字リスト</a></li>
        
          <li><a class="spec" href="/getting-started/keywords-and-maps.html" title="キーワードリストとマップ">キーワードリストとマップ</a></li>
        
          <li><a class="spec" href="/getting-started/modules-and-functions.html" title="モジュールと関数">モジュールと関数</a></li>
        
          <li><a class="spec" href="/getting-started/recursion.html" title="再帰">再帰</a></li>
        
          <li><a class="spec" href="/getting-started/enumerables-and-streams.html" title="Enumerable と stream">Enumerable と stream</a></li>
        
          <li><a class="spec" href="/getting-started/processes.html" title="プロセス">プロセス</a></li>
        
          <li><a class="spec" href="/getting-started/io-and-the-file-system.html" title="IO と ファイルシステム">IO と ファイルシステム</a></li>
        
          <li><a class="spec" href="/getting-started/alias-require-and-import.html" title="alias, require, import">alias, require, import</a></li>
        
          <li><a class="spec" href="/getting-started/module-attributes.html" title="モジュール属性">モジュール属性</a></li>
        
          <li><a class="spec" href="/getting-started/structs.html" title="Struct">Struct</a></li>
        
          <li><a class="spec" href="/getting-started/protocols.html" title="プロトコル">プロトコル</a></li>
        
          <li><a class="spec" href="/getting-started/comprehensions.html" title="内包表記">内包表記</a></li>
        
          <li><a class="spec" href="/getting-started/sigils.html" title="シジル記法">シジル記法</a></li>
        
          <li><a class="spec" href="/getting-started/try-catch-and-rescue.html" title="try、catch、rescue">try、catch、rescue</a></li>
        
          <li><a class="spec" href="/getting-started/typespecs-and-behaviours.html" title="型仕様 と 動作">型仕様 と 動作</a></li>
        
          <li><a class="spec" href="/getting-started/debugging.html" title="デバッグ">デバッグ</a></li>
        
          <li><a class="spec" href="/getting-started/erlang-libraries.html" title="Erlang ライブラリ">Erlang ライブラリ</a></li>
        
          <li><a class="spec" href="/getting-started/where-to-go-next.html" title="次にどこへ行こう">次にどこへ行こう</a></li>
        
      </ol>
    </div>
  
    <div class="widget">
     <h3 class="widget-title">Mix と OTP</h3>
      <ol>
        
          <li><a class="spec" href="/getting-started/mix-otp/introduction-to-mix.html" title="入門 Mix">入門 Mix</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/agent.html" title="エージェント">エージェント</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/genserver.html" title="GenServer">GenServer</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/supervisor-and-application.html" title="スーパーバイザとアプリ">スーパーバイザとアプリ</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/dynamic-supervisor.html" title="動的スーパーバイザ">動的スーパーバイザ</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/ets.html" title="ETS">ETS</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/dependencies-and-umbrella-projects.html" title="依存関係と Umbrella プロジェクト">依存関係と Umbrella プロジェクト</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/task-and-gen-tcp.html" title="タスクと gen_tcp">タスクと gen_tcp</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/docs-tests-and-with.html" title="Doctests, patterns and with">Doctests, patterns and with</a></li>
        
          <li><a class="spec" href="/getting-started/mix-otp/distributed-tasks-and-configuration.html" title="分散型タスクと設定">分散型タスクと設定</a></li>
        
      </ol>
    </div>
  
    <div class="widget">
     <h3 class="widget-title">メタプログラミング Elixir</h3>
      <ol>
        
          <li><a class="spec" href="/getting-started/meta/quote-and-unquote.html" title="Quote と unquote">Quote と unquote</a></li>
        
          <li><a class="spec" href="/getting-started/meta/macros.html" title="マクロ">マクロ</a></li>
        
          <li><a class="spec" href="/getting-started/meta/domain-specific-languages.html" title="DSL (ドメイン固有言語)">DSL (ドメイン固有言語)</a></li>
        
      </ol>
    </div>
  

  <div id="elixir-radar" class="widget">
  <h3 class="widget-title">Elixir Radar Newsletter</h3>
  <p>A weekly Elixir email newsletter with content curated by Plataformatec.</p>
  <div class="elixir-radar-cta">
    <div class="cta-copy">
      <div class="cta-title">
        Elixir Radar
      </div>
      <div class="cta-subtitle">
        weekly newsletter
      </div>
    </div>
    <div class="cta-button-container">
      <a href="http://plataformatec.com.br/elixir-radar/weekly-newsletter?utm_campaign=elixir_lang_cta&utm_medium=cta&utm_source=elixir_lang_website" class="cta-button">
        Subscribe now
      </a>
    </div>
  </div>
</div>

  <div id="distilled-by" class="widget">
  <h3 class="widget-title">Created at</h3>
  <ul>
    <li class="image"><a href="http://plataformatec.com.br" title="Plataformatec"><img src="/images/logo/plataformatec.png" alt="Plataformatec Logo" width="190" height="74" /></a></li>
  </ul>

  <p>
    <a class="spec" href="http://plataformatec.com.br">Plataformatec</a> offers consulting and development services for companies using Elixir.
  </p>
</div>

</div>

<div id="content">
  <article>
    <h1 id="alias-require-and-import">alias, require, and import</h1>

<div id="toc" class="toc"></div>

<p>In order to facilitate software reuse, Elixir provides three directives (<code class="highlighter-rouge">alias</code>, <code class="highlighter-rouge">require</code> and <code class="highlighter-rouge">import</code>) plus a macro called <code class="highlighter-rouge">use</code> summarized below:</p>

<div class="language-elixir highlighter-rouge"><pre class="highlight"><code><span class="c1"># Alias the module so it can be called as Bar instead of Foo.Bar</span>
<span class="n">alias</span> <span class="no">Foo</span><span class="o">.</span><span class="no">Bar</span><span class="p">,</span> <span class="ss">as:</span> <span class="no">Bar</span>

<span class="c1"># Require the module in order to use its macros</span>
<span class="kn">require</span> <span class="no">Foo</span>

<span class="c1"># Import functions from Foo so they can be called without the `Foo.` prefix</span>
<span class="kn">import</span> <span class="no">Foo</span>

<span class="c1"># Invokes the custom code defined in Foo as an extension point</span>
<span class="kn">use</span> <span class="no">Foo</span>
</code></pre>
</div>

<p>We are going to explore them in detail now. Keep in mind the first three are called directives because they have <strong>lexical scope</strong>, while <code class="highlighter-rouge">use</code> is a common extension point that allows the used module to inject code.</p>

<h2 id="alias">alias</h2>

<p><code class="highlighter-rouge">alias</code> allows you to set up aliases for any given module name.</p>

<p>Imagine a module uses a specialized list implemented in <code class="highlighter-rouge">Math.List</code>. The <code class="highlighter-rouge">alias</code> directive allows referring to <code class="highlighter-rouge">Math.List</code> just as <code class="highlighter-rouge">List</code> within the module definition:</p>

<div class="language-elixir highlighter-rouge"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">Stats</span> <span class="k">do</span>
  <span class="n">alias</span> <span class="no">Math</span><span class="o">.</span><span class="no">List</span><span class="p">,</span> <span class="ss">as:</span> <span class="no">List</span>
  <span class="c1"># In the remaining module definition List expands to Math.List.</span>
<span class="k">end</span>
</code></pre>
</div>

<p>The original <code class="highlighter-rouge">List</code> can still be accessed within <code class="highlighter-rouge">Stats</code> by the fully-qualified name <code class="highlighter-rouge">Elixir.List</code>.</p>

<blockquote>
  <p>Note: All modules defined in Elixir are defined inside the main <code class="highlighter-rouge">Elixir</code> namespace. However, for convenience, you can omit “Elixir.” when referencing them.</p>
</blockquote>

<p>Aliases are frequently used to define shortcuts. In fact, calling <code class="highlighter-rouge">alias</code> without an <code class="highlighter-rouge">:as</code> option sets the alias automatically to the last part of the module name, for example:</p>

<div class="language-elixir highlighter-rouge"><pre class="highlight"><code><span class="n">alias</span> <span class="no">Math</span><span class="o">.</span><span class="no">List</span>
</code></pre>
</div>

<p>Is the same as:</p>

<div class="language-elixir highlighter-rouge"><pre class="highlight"><code><span class="n">alias</span> <span class="no">Math</span><span class="o">.</span><span class="no">List</span><span class="p">,</span> <span class="ss">as:</span> <span class="no">List</span>
</code></pre>
</div>

<p>Note that <code class="highlighter-rouge">alias</code> is <strong>lexically scoped</strong>, which allows you to set aliases inside specific functions:</p>

<div class="language-elixir highlighter-rouge"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">Math</span> <span class="k">do</span>
  <span class="k">def</span> <span class="n">plus</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">alias</span> <span class="no">Math</span><span class="o">.</span><span class="no">List</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">minus</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">do</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>In the example above, since we are invoking <code class="highlighter-rouge">alias</code> inside the function <code class="highlighter-rouge">plus/2</code>, the alias will be valid only inside the function <code class="highlighter-rouge">plus/2</code>. <code class="highlighter-rouge">minus/2</code> won’t be affected at all.</p>

<h2 id="require">require</h2>

<p>Elixir provides macros as a mechanism for meta-programming (writing code that generates code). Macros are expanded at compile time.</p>

<p>Public functions in modules are globally available, but in order to use macros, you need to opt-in by requiring the module they are defined in.</p>

<pre><code class="language-iex">iex&gt; Integer.is_odd(3)
** (UndefinedFunctionError) function Integer.is_odd/1 is undefined or private. However there is a macro with the same name and arity. Be sure to require Integer if you intend to invoke this macro
iex&gt; require Integer
Integer
iex&gt; Integer.is_odd(3)
true
</code></pre>

<p>In Elixir, <code class="highlighter-rouge">Integer.is_odd/1</code> is defined as a macro so that it can be used as a guard. This means that, in order to invoke <code class="highlighter-rouge">Integer.is_odd/1</code>, we need to first require the <code class="highlighter-rouge">Integer</code> module.</p>

<p>Note that like the <code class="highlighter-rouge">alias</code> directive, <code class="highlighter-rouge">require</code> is also lexically scoped. We will talk more about macros in a later chapter.</p>

<h2 id="import">import</h2>

<p>We use <code class="highlighter-rouge">import</code> whenever we want to easily access functions or macros from other modules without using the fully-qualified name. For instance, if we want to use the <code class="highlighter-rouge">duplicate/2</code> function from the <code class="highlighter-rouge">List</code> module several times, we can import it:</p>

<pre><code class="language-iex">iex&gt; import List, only: [duplicate: 2]
List
iex&gt; duplicate :ok, 3
[:ok, :ok, :ok]
</code></pre>

<p>In this case, we are importing only the function <code class="highlighter-rouge">duplicate</code> (with arity 2) from <code class="highlighter-rouge">List</code>. Although <code class="highlighter-rouge">:only</code> is optional, its usage is recommended in order to avoid importing all the functions of a given module inside the namespace. <code class="highlighter-rouge">:except</code> could also be given as an option in order to import everything in a module <em>except</em> a list of functions.</p>

<p><code class="highlighter-rouge">import</code> also supports <code class="highlighter-rouge">:macros</code> and <code class="highlighter-rouge">:functions</code> to be given to <code class="highlighter-rouge">:only</code>. For example, to import all macros, one could write:</p>

<div class="language-elixir highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="no">Integer</span><span class="p">,</span> <span class="ss">only:</span> <span class="ss">:macros</span>
</code></pre>
</div>

<p>Or to import all functions, you could write:</p>

<div class="language-elixir highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="no">Integer</span><span class="p">,</span> <span class="ss">only:</span> <span class="ss">:functions</span>
</code></pre>
</div>

<p>Note that <code class="highlighter-rouge">import</code> is <strong>lexically scoped</strong> too. This means that we can import specific macros or functions inside function definitions:</p>

<div class="language-elixir highlighter-rouge"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">Math</span> <span class="k">do</span>
  <span class="k">def</span> <span class="n">some_function</span> <span class="k">do</span>
    <span class="kn">import</span> <span class="no">List</span><span class="p">,</span> <span class="ss">only:</span> <span class="p">[</span><span class="ss">duplicate:</span> <span class="m">2</span><span class="p">]</span>
    <span class="n">duplicate</span><span class="p">(</span><span class="ss">:ok</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>In the example above, the imported <code class="highlighter-rouge">List.duplicate/2</code> is only visible within that specific function. <code class="highlighter-rouge">duplicate/2</code> won’t be available in any other function in that module (or any other module for that matter).</p>

<p>Note that <code class="highlighter-rouge">import</code>ing a module automatically <code class="highlighter-rouge">require</code>s it.</p>

<h2 id="use">use</h2>

<p>The <code class="highlighter-rouge">use</code> macro is frequently used as an extension point. This means that, when you use a module <code class="highlighter-rouge">FooBar</code>, you allow that module to inject <em>any</em> code in the current module, such as importing itself or other modules, defining new functions, setting a module state, etc.</p>

<p>For example, in order to write tests using the ExUnit framework, a developer should use the <code class="highlighter-rouge">ExUnit.Case</code> module:</p>

<div class="language-elixir highlighter-rouge"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">AssertionTest</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">ExUnit</span><span class="o">.</span><span class="no">Case</span><span class="p">,</span> <span class="ss">async:</span> <span class="no">true</span>

  <span class="n">test</span> <span class="sd">"</span><span class="s2">always pass"</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="no">true</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Behind the scenes, <code class="highlighter-rouge">use</code> requires the given module and then calls the <code class="highlighter-rouge">__using__/1</code> callback on it allowing the module to inject some code into the current context. Generally speaking, the following module:</p>

<div class="language-elixir highlighter-rouge"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">Example</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Feature</span><span class="p">,</span> <span class="ss">option:</span> <span class="ss">:value</span>
<span class="k">end</span>
</code></pre>
</div>

<p>is compiled into</p>

<div class="language-elixir highlighter-rouge"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">Example</span> <span class="k">do</span>
  <span class="kn">require</span> <span class="no">Feature</span>
  <span class="no">Feature</span><span class="o">.</span><span class="n">__using__</span><span class="p">(</span><span class="ss">option:</span> <span class="ss">:value</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Since <code class="highlighter-rouge">use</code> allows any code to run, we can’t really know the side-effects of using a module without reading its documentation. For this reason, <code class="highlighter-rouge">import</code> and <code class="highlighter-rouge">alias</code> are often preferred, as their semantics are defined by the language.</p>

<h2 id="understanding-aliases">Understanding Aliases</h2>

<p>At this point, you may be wondering: what exactly is an Elixir alias and how is it represented?</p>

<p>An alias in Elixir is a capitalized identifier (like <code class="highlighter-rouge">String</code>, <code class="highlighter-rouge">Keyword</code>, etc) which is converted to an atom during compilation. For instance, the <code class="highlighter-rouge">String</code> alias translates by default to the atom <code class="highlighter-rouge">:"Elixir.String"</code>:</p>

<pre><code class="language-iex">iex&gt; is_atom(String)
true
iex&gt; to_string(String)
"Elixir.String"
iex&gt; :"Elixir.String" == String
true
</code></pre>

<p>By using the <code class="highlighter-rouge">alias/2</code> directive, we are changing the atom the alias expands to.</p>

<p>Aliases expand to atoms because in the Erlang <abbr title="Virtual Machine">VM</abbr> (and consequently Elixir) modules are always represented by atoms. For example, that’s the mechanism we use to call Erlang modules:</p>

<pre><code class="language-iex">iex&gt; :lists.flatten([1, [2], 3])
[1, 2, 3]
</code></pre>

<h2 id="module-nesting">Module nesting</h2>

<p>Now that we have talked about aliases, we can talk about nesting and how it works in Elixir. Consider the following example:</p>

<div class="language-elixir highlighter-rouge"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">Foo</span> <span class="k">do</span>
  <span class="k">defmodule</span> <span class="no">Bar</span> <span class="k">do</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>The example above will define two modules: <code class="highlighter-rouge">Foo</code> and <code class="highlighter-rouge">Foo.Bar</code>. The second can be accessed as <code class="highlighter-rouge">Bar</code> inside <code class="highlighter-rouge">Foo</code> as long as they are in the same lexical scope. The code above is exactly the same as:</p>

<div class="language-elixir highlighter-rouge"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">Elixir</span><span class="o">.</span><span class="no">Foo</span> <span class="k">do</span>
  <span class="k">defmodule</span> <span class="no">Elixir</span><span class="o">.</span><span class="no">Foo</span><span class="o">.</span><span class="no">Bar</span> <span class="k">do</span>
  <span class="k">end</span>
  <span class="n">alias</span> <span class="no">Elixir</span><span class="o">.</span><span class="no">Foo</span><span class="o">.</span><span class="no">Bar</span><span class="p">,</span> <span class="ss">as:</span> <span class="no">Bar</span>
<span class="k">end</span>
</code></pre>
</div>

<p>If, later, the <code class="highlighter-rouge">Bar</code> module is moved outside the <code class="highlighter-rouge">Foo</code> module definition, it must be referenced by its full name (<code class="highlighter-rouge">Foo.Bar</code>) or an alias must be set using the <code class="highlighter-rouge">alias</code> directive discussed above.</p>

<p><strong>Note</strong>: in Elixir, you don’t have to define the <code class="highlighter-rouge">Foo</code> module before being able to define the <code class="highlighter-rouge">Foo.Bar</code> module, as the language translates all module names to atoms. You can define arbitrarily-nested modules without defining any module in the chain (e.g., <code class="highlighter-rouge">Foo.Bar.Baz</code> without defining <code class="highlighter-rouge">Foo</code> or <code class="highlighter-rouge">Foo.Bar</code> first).</p>

<p>As we will see in later chapters, aliases also play a crucial role in macros, to guarantee they are hygienic.</p>

<h2 id="multi-aliasimportrequireuse">Multi alias/import/require/use</h2>

<p>From Elixir v1.2, it is possible to alias, import or require multiple modules at once. This is particularly useful once we start nesting modules, which is very common when building Elixir applications. For example, imagine you have an application where all modules are nested under <code class="highlighter-rouge">MyApp</code>, you can alias the modules <code class="highlighter-rouge">MyApp.Foo</code>, <code class="highlighter-rouge">MyApp.Bar</code> and <code class="highlighter-rouge">MyApp.Baz</code> at once as follows:</p>

<div class="language-elixir highlighter-rouge"><pre class="highlight"><code><span class="n">alias</span> <span class="no">MyApp</span><span class="o">.</span><span class="p">{</span><span class="no">Foo</span><span class="p">,</span> <span class="no">Bar</span><span class="p">,</span> <span class="no">Baz</span><span class="p">}</span>
</code></pre>
</div>

<p>With this, we have finished our tour of Elixir modules. The last topic to cover is module attributes.</p>

  </article><!-- .hfeed -->

  <div id="edit-on-github">
    <span>Is something wrong?</span>
    <a href="/edit/master/ja/getting-started/alias-require-and-import.markdown">
      Edit this page on GitHub.
    </a>
  </div>

  
  
  
  
  

  
  
    
  
    
  
    
  

</div><!-- #content -->

      </div><!-- #main -->

      <div class="clear"></div>

      <div id="copyright">
        &copy; 2012–2019 <a href="http://plataformatec.com.br/">Plataformatec</a>. All rights reserved.
      </div>
    </div><!-- .wrap -->
  </div><!-- #container -->

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
  <script src="/js/toc/toc.js" type="text/javascript" charset="utf-8"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $('.toc').toc({
        title: '',
        listType: 'ol',
        minimumHeaders: 2,
        headers: 'h2, h3, h4, h5, h6',
        linkHere: true,
        linkHereTitle: 'Link here',
        backToTop: true,
        backToTopId: 'toc',
        backToTopTitle: 'Back to Table of Contents',
      });
      $('.jekyll-toc-header a.jekyll-toc-link-here span.jekyll-toc-icon').addClass('icon icon-link');
      $('.jekyll-toc-header a.jekyll-toc-back-to-top span.jekyll-toc-icon').addClass('icon icon-chevron-up');
    });
  </script>
</body>
</html>

