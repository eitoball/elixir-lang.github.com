msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2018-08-11 01:00+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: Keyword lists and maps\n"
"redirect_from: /getting-started/maps-and-dicts.html\n"
"---"
msgstr ""
"---\n"
"layout: getting-started\n"
"title: キーワードリストとマップ\n"
"redirect_from: /getting-started/maps-and-dicts.html\n"
"---"

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid ""
"So far we haven't discussed any associative data structures, i.e. data structu"
"res that are able to associate a certain value (or multiple values) to a key. "
"Different languages call these different names like dictionaries, hashes, asso"
"ciative arrays, etc."
msgstr ""
"今までのところ、とある値をキーと関連づけすることが出来るようなデータ構造についてまだ触れていません。言語によってはそういうデータ構造のことを辞書、ハッシュ、"
"あるいは連想配列という風に異なる名前で呼んでいます。"

msgid ""
"In Elixir, we have two main associative data structures: keyword lists and map"
"s. It's time to learn more about them!"
msgstr "Elixir では主にキーワードリストとマップという二つの連想データ構造があります。これらについて学んでいきましょう。"

msgid "## Keyword lists"
msgstr "## キーワードリスト"

msgid ""
"In many functional programming languages, it is common to use a list of 2-item"
" tuples as the representation of a key-value data structure. In Elixir, when w"
"e have a list of tuples and the first item of the tuple (i.e. the key) is an a"
"tom, we call it a keyword list:"
msgstr ""
"大抵の関数型プログラミング言語は、キーと値を表現する為にタプルのリストを使うのが一般的です。Elixir では、タプルの最初の要素（キー）としてアトムを使っているタプルのリ"
"ストのことを、キーワードリストと呼んでいます。"

msgid ""
"```iex\n"
"iex> list = [{:a, 1}, {:b, 2}]\n"
"[a: 1, b: 2]\n"
"iex> list == [a: 1, b: 2]\n"
"true\n"
"```"
msgstr ""

msgid ""
"As you can see above, Elixir supports a special syntax for defining such lists"
": `[key: value]`. Underneath it maps to the same list of tuples as above. Sinc"
"e keyword lists are lists, we can use all operations available to lists. For e"
"xample, we can use `++` to add new values to a keyword list:"
msgstr ""
"上のコードで分かる通り、Elixir は同じことを `[key: value]` という風に書ける特別な構文をサポートしています。キーワードリストはリストで"
"すから、リストに対して行える全ての操作がキーワードリストにも利用できます。例えば、新しく値を追加する為に `++` を使うことができます。"

msgid ""
"```iex\n"
"iex> list ++ [c: 3]\n"
"[a: 1, b: 2, c: 3]\n"
"iex> [a: 0] ++ list\n"
"[a: 0, a: 1, b: 2]\n"
"```"
msgstr ""

msgid "Note that values added to the front are the ones fetched on lookup:"
msgstr "探索する際に引き出される値が先頭に追加された値であることに注意してください。"

msgid ""
"```iex\n"
"iex> new_list = [a: 0] ++ list\n"
"[a: 0, a: 1, b: 2]\n"
"iex> new_list[:a]\n"
"0\n"
"```"
msgstr ""

msgid "Keyword lists are important because they have three special characteristics:"
msgstr "キーワードリストは以下に挙げる 3 つに特徴づけられた重要なものです。"

msgid ""
"  * Keys must be atoms.\n"
"  * Keys are ordered, as specified by the developer.\n"
"  * Keys can be given more than once."
msgstr ""
"  * キーはアトムである\n"
"  * キーは開発者が指定した通りに並ぶ\n"
"  * キーは何度でも使える"

msgid ""
"For example, [the Ecto library](https://github.com/elixir-lang/ecto) makes use"
" of these features to provide an elegant DSL for writing database queries:"
msgstr ""
"例えば、[Ecto ライブラリ](https://github.com/elixir-lang/ecto) ではデータベースのクエリを書く為に使われる洗練さ"
"れた DSL を提供する為にそれら機能を利用しています。"

msgid ""
"```elixir\n"
"query = from w in Weather,\n"
"      where: w.prcp > 0,\n"
"      where: w.temp < 20,\n"
"     select: w\n"
"```"
msgstr ""

msgid ""
"These characteristics are what prompted keyword lists to be the default mechan"
"ism for passing options to functions in Elixir. In chapter 5, when we discusse"
"d the `if/2` macro, we mentioned the following syntax is supported:"
msgstr ""
"Elixir で関数にオプションを渡す手法がキーワードリストとなっているのは、これらの特性によるきっかけです。5 章でマクロの `if/2` について触れた"
"時に、以下のような構文がサポートされていることを言及しました。"

msgid ""
"```iex\n"
"iex> if false, do: :this, else: :that\n"
":that\n"
"```"
msgstr ""

msgid ""
"The `do:` and `else:` pairs are keyword lists! In fact, the call above is equi"
"valent to:"
msgstr "`do:` と `else:` という二つのペアはキーワードリストなのです！実際に上記の呼び出しは以下と同等です。"

msgid ""
"```iex\n"
"iex> if(false, [do: :this, else: :that])\n"
":that\n"
"```"
msgstr ""

msgid "Which, as we have seen above, is the same as:"
msgstr "以下もまた上記と同じように、どちらも等しいものです。"

msgid ""
"```iex\n"
"iex> if(false, [{:do, :this}, {:else, :that}])\n"
":that\n"
"```"
msgstr ""

msgid ""
"In general, when the keyword list is the last argument of a function, the squa"
"re brackets are optional."
msgstr "一般的にキーワードリストが関数の最後の引数である時は、角括弧を任意で省略できます。"

msgid ""
"Although we can pattern match on keyword lists, it is rarely done in practice "
"since pattern matching on lists requires the number of items and their order t"
"o match:"
msgstr "キーワードリストでパターンマッチを利用できるのですが、要素の数とその順序が一致している必要がある為に殆ど利用されません。"

msgid ""
"```iex\n"
"iex> [a: a] = [a: 1]\n"
"[a: 1]\n"
"iex> a\n"
"1\n"
"iex> [a: a] = [a: 1, b: 2]\n"
"** (MatchError) no match of right hand side value: [a: 1, b: 2]\n"
"iex> [b: b, a: a] = [a: 1, b: 2]\n"
"** (MatchError) no match of right hand side value: [a: 1, b: 2]\n"
"```"
msgstr ""

msgid ""
"In order to manipulate keyword lists, Elixir provides [the `Keyword` module](h"
"ttps://hexdocs.pm/elixir/Keyword.html). Remember, though, keyword lists are si"
"mply lists, and as such they provide the same linear performance characteristi"
"cs as lists. The longer the list, the longer it will take to find a key, to co"
"unt the number of items, and so on. For this reason, keyword lists are used in"
" Elixir mainly for passing optional values. If you need to store many items or"
" guarantee one-key associates with at maximum one-value, you should use maps i"
"nstead."
msgstr ""
"Elixir はキーワードリストを操作する為に [`Keyword` モジュール](https://hexdocs.pm/elixir/Keyword.ht"
"ml) を提供しています。ただし、キーワードリストは単なるリストであり、それ自体はリストとして同じ線形的な運用特性があることは覚えておいてください。リストが"
"長いほどキーの検索や要素数のカウントに時間がかかります。その理由は、Elixir のキーワードリストが主にオプション値を渡す為に使われる為です。要素をたくさ"
"ん保持したり、一つのキーが一つの値とだけ関連づけられることの保証が必要な場合は、キーワードリストの代わりにマップを使うべきです。"

msgid "## Maps"
msgstr "## マップ"

msgid ""
"Whenever you need a key-value store, maps are the \"go to\" data structure in El"
"ixir. A map is created using the `%{}` syntax:"
msgstr "キーと値のペアで保持したいものがある時にはマップが打ってつけのデータ構造です。マップは `%{}` という構文を使って作成します。"

msgid ""
"```iex\n"
"iex> map = %{:a => 1, 2 => :b}\n"
"%{2 => :b, :a => 1}\n"
"iex> map[:a]\n"
"1\n"
"iex> map[2]\n"
":b\n"
"iex> map[:c]\n"
"nil\n"
"```"
msgstr ""

msgid "Compared to keyword lists, we can already see two differences:"
msgstr "キーワードリストと比較すると二つの違いが見て取れます。"

msgid ""
"  * Maps allow any value as a key.\n"
"  * Maps' keys do not follow any ordering."
msgstr ""
"  * マップはどんな値もキーにできる\n"
"  * マップのキーは順序がない"

msgid ""
"In contrast to keyword lists, maps are very useful with pattern matching. When"
" a map is used in a pattern, it will always match on a subset of the given val"
"ue:"
msgstr "キーワードリストと違ってマップのパターンマッチは非常に有用です。パターンにマップを使うと、与えられた値のサブセットとマッチします。"

msgid ""
"```iex\n"
"iex> %{} = %{:a => 1, 2 => :b}\n"
"%{2 => :b, :a => 1}\n"
"iex> %{:a => a} = %{:a => 1, 2 => :b}\n"
"%{2 => :b, :a => 1}\n"
"iex> a\n"
"1\n"
"iex> %{:c => c} = %{:a => 1, 2 => :b}\n"
"** (MatchError) no match of right hand side value: %{2 => :b, :a => 1}\n"
"```"
msgstr ""

msgid ""
"As shown above, a map matches as long as the keys in the pattern exist in the "
"given map. Therefore, an empty map matches all maps."
msgstr "見ての通り、パターン内のキーが与えられたマップ内に存在する間はマッチします。よって、空のマップは完全にどのマップとも一致します。"

msgid "Variables can be used when accessing, matching and adding map keys:"
msgstr "変数を使って値にアクセスしたり、マッチングやキーを追加することが出来ます。"

msgid ""
"```iex\n"
"iex> n = 1\n"
"1\n"
"iex> map = %{n => :one}\n"
"%{1 => :one}\n"
"iex> map[n]\n"
":one\n"
"iex> %{^n => :one} = %{1 => :one, 2 => :two, 3 => :three}\n"
"%{1 => :one, 2 => :two, 3 => :three}\n"
"```"
msgstr ""

msgid ""
"[The `Map` module](https://hexdocs.pm/elixir/Map.html) provides a very similar"
" API to the `Keyword` module with convenience functions to manipulate maps:"
msgstr ""
"[`Map` モジュール](https://hexdocs.pm/elixir/Map.html) は `Keyword` モジュールが備えている便利な関数"
"とよく似た API をマップの操作の為に提供しています。"

msgid ""
"```iex\n"
"iex> Map.get(%{:a => 1, 2 => :b}, :a)\n"
"1\n"
"iex> Map.put(%{:a => 1, 2 => :b}, :c, 3)\n"
"%{2 => :b, :a => 1, :c => 3}\n"
"iex> Map.to_list(%{:a => 1, 2 => :b})\n"
"[{2, :b}, {:a, 1}]\n"
"```"
msgstr ""

msgid "Maps have the following syntax for updating a key's value:"
msgstr "マップはキーが持つ値を更新する為に以下の構文をサポートします。"

msgid ""
"```iex\n"
"iex> map = %{:a => 1, 2 => :b}\n"
"%{2 => :b, :a => 1}"
msgstr ""

msgid ""
"iex> %{map | 2 => \"two\"}\n"
"%{2 => \"two\", :a => 1}\n"
"iex> %{map | :c => 3}\n"
"** (KeyError) key :c not found in: %{2 => :b, :a => 1}\n"
"```"
msgstr ""

msgid ""
"The syntax above requires the given key to exist. It cannot be used to add new"
" keys. For example, using it with the `:c` key failed because there is no `:c`"
" in the map."
msgstr ""
"上記の構文は与えられたキーが存在する必要があります。これを新しいキーの追加には使えません。`:c` というキーを使った例では、マップ内に `:c` が存在し"
"ないので失敗しています。"

msgid ""
"When all the keys in a map are atoms, you can use the keyword syntax for conve"
"nience:"
msgstr "マップ内のすべてのキーがアトムの時は便利なキーワード構文を使って簡潔に書けます。"

msgid ""
"```iex\n"
"iex> map = %{a: 1, b: 2}\n"
"%{a: 1, b: 2}\n"
"```"
msgstr ""

msgid ""
"Another interesting property of maps is that they provide their own syntax for"
" accessing atom keys:"
msgstr "マップのもう一つ興味深い特質として、アトムのキーにアクセスする独自の構文が用意されていることが挙げられます。"

msgid ""
"iex> map.a\n"
"1\n"
"iex> map.c\n"
"** (KeyError) key :c not found in: %{2 => :b, :a => 1}\n"
"```"
msgstr ""

msgid ""
"Elixir developers typically prefer to use the `map.field` syntax and pattern m"
"atching instead of the functions in the `Map` module when working with maps be"
"cause they lead to an assertive style of programming. [This blog post](http://"
"blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/) provide"
"s insight and examples on how you get more concise and faster software by writ"
"ing assertive code in Elixir."
msgstr ""
"一般的に Elixir を使う開発者は、マップを用いた操作で `Map` モジュールの関数を使うよりも、パターンマッチと `map.field` という構文"
"を好んで使います。その方が確定的なコードを書けるようになるからです。[このブログ記事](http://blog.plataformatec.com.br/2"
"014/09/writing-assertive-code-with-elixir/) では、Elixir の確定的なコードで如何に簡潔かつ高速なソフトウェ"
"アを手に入れるかの例と洞察を紹介しています。"

msgid ""
"> Note: Maps were recently introduced into the Erlang <abbr title=\"Virtual Mac"
"hine\">VM</abbr> and only from Elixir v1.2 are they capable of holding millions"
" of keys efficiently. Therefore, if you are working with previous Elixir versi"
"ons (v1.0 or v1.1) and you need to support at least hundreds of keys, you may "
"consider using [the `HashDict` module](https://hexdocs.pm/elixir/HashDict.html"
")."
msgstr ""
"Note: マップは最近になって Erlang <abbr title=\"Virtual Machine\">VM</abbr> に導入されたばかりで、何百万"
"という沢山のキーを効率的に保持できるのは Elixir v1.2 以降だけです。もしも今、あなたが以前のバージョンの Elixir (v1.0 or v1."
"1) を使っていて、少なくとも数百のキーをサポートする必要があるなら、[`HashDict` モジュール](https://hexdocs.pm/elixi"
"r/HashDict.html) の使用を検討してもよいかも知れません。"

msgid "## Nested data structures"
msgstr "## ネストされたデータ構造"

msgid ""
"Often we will have maps inside maps, or even keywords lists inside maps, and s"
"o forth. Elixir provides conveniences for manipulating nested data structures "
"via the `put_in/2`, `update_in/2` and other macros giving the same convenience"
"s you would find in imperative languages while keeping the immutable propertie"
"s of the language."
msgstr ""
"マップの中でさらにマップやキーワードリスト等が必要なケースが往々にしてあります。Elixir は `put_in/2` や `update_in/2` 及び"
"、命令型言語に見られるものと同様に便利なその他のマクロよって、属性をイミュータブルに保ったまま多次元のデータ構造を操作するという利便性を提供しています。"

msgid "Imagine you have the following structure:"
msgstr "以下のような構造があるとします。"

msgid ""
"```iex\n"
"iex> users = [\n"
"  john: %{name: \"John\", age: 27, languages: [\"Erlang\", \"Ruby\", \"Elixir\"]},\n"
"  mary: %{name: \"Mary\", age: 29, languages: [\"Elixir\", \"F#\", \"Clojure\"]}\n"
"]\n"
"[john: %{age: 27, languages: [\"Erlang\", \"Ruby\", \"Elixir\"], name: \"John\"},\n"
" mary: %{age: 29, languages: [\"Elixir\", \"F#\", \"Clojure\"], name: \"Mary\"}]\n"
"```"
msgstr ""

msgid ""
"We have a keyword list of users where each value is a map containing the name,"
" age and a list of programming languages each user likes. If we wanted to acce"
"ss the age for john, we could write:"
msgstr "名前と年齢、そして各ユーザーが好きな言語リストで構成されるマップを含んだキーワードリストがあります。John の年齢にアクセスしたい時はこう書きます。"

msgid ""
"```iex\n"
"iex> users[:john].age\n"
"27\n"
"```"
msgstr ""

msgid "It happens we can also use this same syntax for updating the value:"
msgstr "これと同じ構文を値の更新に使うこともできます。"

msgid ""
"```iex\n"
"iex> users = put_in users[:john].age, 31\n"
"[john: %{age: 31, languages: [\"Erlang\", \"Ruby\", \"Elixir\"], name: \"John\"},\n"
" mary: %{age: 29, languages: [\"Elixir\", \"F#\", \"Clojure\"], name: \"Mary\"}]\n"
"```"
msgstr ""

msgid ""
"The `update_in/2` macro is similar but allows us to pass a function that contr"
"ols how the value changes. For example, let's remove \"Clojure\" from Mary's lis"
"t of languages:"
msgstr ""
"マクロ `update_in/2` もこれと似ていますが、値をどのように変更するかを制御する為に関数を渡すことができます。例えば、Mary の言語リストから"
" \"Clojure\" を削除してみましょう。"

msgid ""
"```iex\n"
"iex> users = update_in users[:mary].languages, fn languages -> List.delete(lan"
"guages, \"Clojure\") end\n"
"[john: %{age: 31, languages: [\"Erlang\", \"Ruby\", \"Elixir\"], name: \"John\"},\n"
" mary: %{age: 29, languages: [\"Elixir\", \"F#\"], name: \"Mary\"}]\n"
"```"
msgstr ""

msgid ""
"There is more to learn about `put_in/2` and `update_in/2`, including the `get_"
"and_update_in/2` that allows us to extract a value and update the data structu"
"re at once. There are also `put_in/3`, `update_in/3` and `get_and_update_in/3`"
" which allow dynamic access into the data structure. [Check their respective d"
"ocumentation in the `Kernel` module for more information](https://hexdocs.pm/e"
"lixir/Kernel.html)."
msgstr ""
"値を取り除いたり、データ構造を一度に更新するのことができる `get_and_update_in/2` も含めて `put_in/2` と `update_"
"in/2` をもっと知る必要があるでしょう。動的にデータ構造へアクセスできる `put_in/3` と `update_in/3` 、 `get_and_u"
"pdate_in/3` もあります。それぞれの詳しいドキュメントは [`Kernel` モジュール](https://hexdocs.pm/elixir/K"
"ernel.html) を参照してください。"

msgid ""
"This concludes our introduction to associative data structures in Elixir. You "
"will find out that, given keyword lists and maps, you will always have the rig"
"ht tool to tackle problems that require associative data structures in Elixir."
msgstr ""
"ここで Elixir における連想データ構造の紹介を終わりとします。キーワードリストとマップがある時に、あなたはいつでも連想データ構造を必要とする問題に立ち"
"向かう為の適切なツールがあることが分かると思います。"
