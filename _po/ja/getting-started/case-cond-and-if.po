msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2019-06-22 19:53+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: case, cond, and if\n"
"---"
msgstr ""

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid ""
"In this chapter, we will learn about the `case`, `cond`, and `if` control flow"
" structures."
msgstr "この章では、 case, cond, if といった制御構造について学んでいきます。"

msgid "## `case`"
msgstr ""

msgid ""
"`case` allows us to compare a value against many patterns until we find a matc"
"hing one:"
msgstr "`case` を使うと、いくつかあるパターンのいずれかにマッチするまで値を比較することができます。"

msgid ""
"```iex\n"
"iex> case {1, 2, 3} do\n"
"...>   {4, 5, 6} ->\n"
"...>     \"This clause won't match\"\n"
"...>   {1, x, 3} ->\n"
"...>     \"This clause will match and bind x to 2 in this clause\"\n"
"...>   _ ->\n"
"...>     \"This clause would match any value\"\n"
"...> end\n"
"\"This clause will match and bind x to 2 in this clause\"\n"
"```"
msgstr ""

msgid ""
"If you want to pattern match against an existing variable, you need to use the"
" `^` operator:"
msgstr "すでに存在している変数に対してパターンマッチを行うには `^` 演算子を使います。"

msgid ""
"```iex\n"
"iex> x = 1\n"
"1\n"
"iex> case 10 do\n"
"...>   ^x -> \"Won't match\"\n"
"...>   _ -> \"Will match\"\n"
"...> end\n"
"\"Will match\"\n"
"```"
msgstr ""

msgid "Clauses also allow extra conditions to be specified via guards:"
msgstr "節はガードを使って条件を指定することもできます。"

msgid ""
"```iex\n"
"iex> case {1, 2, 3} do\n"
"...>   {1, x, 3} when x > 0 ->\n"
"...>     \"Will match\"\n"
"...>   _ ->\n"
"...>     \"Would match, if guard condition were not satisfied\"\n"
"...> end\n"
"\"Will match\"\n"
"```"
msgstr ""

msgid "The first clause above will only match when `x` is positive."
msgstr "上記の例にある最初の節では `x` が整数の時にマッチします。"

msgid "Keep in mind errors in guards do not leak but simply make the guard fail:"
msgstr "ガードにおけるエラーが処理を抜けることはなく、ただガードに失敗するだけであると覚えておいてください。"

msgid ""
"```iex\n"
"iex> hd(1)\n"
"** (ArgumentError) argument error\n"
"iex> case 1 do\n"
"...>   x when hd(x) -> \"Won't match\"\n"
"...>   x -> \"Got #{x}\"\n"
"...> end\n"
"\"Got 1\"\n"
"```"
msgstr ""

msgid "If none of the clauses match, an error is raised:"
msgstr "いずれの節にもマッチしない時はエラーになります。"

msgid ""
"```iex\n"
"iex> case :ok do\n"
"...>   :error -> \"Won't match\"\n"
"...> end\n"
"** (CaseClauseError) no case clause matching: :ok\n"
"```"
msgstr ""

msgid ""
"Consult [the full documentation for guards](https://hexdocs.pm/elixir/guards.h"
"tml) for more information about guards, how they are used, and what expression"
"s are allowed in them."
msgstr ""
"ガードの使い方や利用できる式について知りたい時は [the full documentation for guards](https://hexdocs.p"
"m/elixir/guards.html) で詳しい情報を得られます。"

msgid "Note anonymous functions can also have multiple clauses and guards:"
msgstr "NOTE: 無名関数は複数の節とガードを含むこともできます。"

msgid ""
"```iex\n"
"iex> f = fn\n"
"...>   x, y when x > 0 -> x + y\n"
"...>   x, y -> x * y\n"
"...> end\n"
"#Function<12.71889879/2 in :erl_eval.expr/5>\n"
"iex> f.(1, 3)\n"
"4\n"
"iex> f.(-1, 3)\n"
"-3\n"
"```"
msgstr ""

msgid ""
"The number of arguments in each anonymous function clause needs to be the same"
", otherwise an error is raised."
msgstr "無名関数の中で節は引数の数が同じでなくてはならず、その数が合わなければエラーになります。"

msgid ""
"```iex\n"
"iex> f2 = fn\n"
"...>   x, y when x > 0 -> x + y\n"
"...>   x, y, z -> x * y + z\n"
"...> end\n"
"** (CompileError) iex:1: cannot mix clauses with different arities in anonymou"
"s functions\n"
"```"
msgstr ""

msgid "## `cond`"
msgstr ""

msgid ""
"`case` is useful when you need to match against different values. However, in "
"many circumstances, we want to check different conditions and find the first o"
"ne that evaluates to true. In such cases, one may use `cond`:"
msgstr ""
"`case` は様々な値に対してマッチさせたい時に有用です。それでも、様々な条件を調べて最初に true と評価されるものを見つけたいことが往々にしてありま"
"す。そういった場合に取る方法のひとつが `cond` です。"

msgid ""
"```iex\n"
"iex> cond do\n"
"...>   2 + 2 == 5 ->\n"
"...>     \"This will not be true\"\n"
"...>   2 * 2 == 3 ->\n"
"...>     \"Nor this\"\n"
"...>   1 + 1 == 2 ->\n"
"...>     \"But this will\"\n"
"...> end\n"
"\"But this will\"\n"
"```"
msgstr ""

msgid ""
"This is equivalent to `else if` clauses in many imperative languages (although"
" used way less frequently here)."
msgstr "これは多くの命令型言語における `else if` に相当するものです(ここではあまり使われません)。"

msgid ""
"If none of the conditions return true, an error (`CondClauseError`) is raised."
" For this reason, it may be necessary to add a final condition, equal to `true"
"`, which will always match:"
msgstr ""
"true を返す条件が見つからないと (`CondClauseError`) になります。この理由は、そういった時に最後では必ず `true` に等しくなる"
"条件を書かなくてはならない為です。"

msgid ""
"```iex\n"
"iex> cond do\n"
"...>   2 + 2 == 5 ->\n"
"...>     \"This is never true\"\n"
"...>   2 * 2 == 3 ->\n"
"...>     \"Nor this\"\n"
"...>   true ->\n"
"...>     \"This is always true (equivalent to else)\"\n"
"...> end\n"
"\"This is always true (equivalent to else)\"\n"
"```"
msgstr ""

msgid "Finally, note `cond` considers any value besides `nil` and `false` to be true:"
msgstr "最後に、 `cond` は `nil` と `false` 以外の如何なる値も `true` と見なすことを覚えておきましょう。"

msgid ""
"```iex\n"
"iex> cond do\n"
"...>   hd([1, 2, 3]) ->\n"
"...>     \"1 is considered as true\"\n"
"...> end\n"
"\"1 is considered as true\"\n"
"```"
msgstr ""

msgid "## `if` and `unless`"
msgstr ""

msgid ""
"Besides `case` and `cond`, Elixir also provides the macros `if/2` and `unless/"
"2` which are useful when you need to check for only one condition:"
msgstr "`case` と `cond` の他、ひとつの条件だけを検証したい時に有用なマクロ `if/2` と `unless/2` も使えます。"

msgid ""
"```iex\n"
"iex> if true do\n"
"...>   \"This works!\"\n"
"...> end\n"
"\"This works!\"\n"
"iex> unless true do\n"
"...>   \"This will never be seen\"\n"
"...> end\n"
"nil\n"
"```"
msgstr ""

msgid ""
"If the condition given to `if/2` returns `false` or `nil`, the body given betw"
"een `do/end` is not executed and instead it returns `nil`. The opposite happen"
"s with `unless/2`."
msgstr ""
"`false` と `nil` を返す条件では `do/end` のブロック間にある内容が実行されず、代わりに `nil` を返します。 `unless` "
"ではこの逆になります。"

msgid "They also support `else` blocks:"
msgstr "これらはブロックで `else` も使えます。"

msgid ""
"```iex\n"
"iex> if nil do\n"
"...>   \"This won't be seen\"\n"
"...> else\n"
"...>   \"This will\"\n"
"...> end\n"
"\"This will\"\n"
"```"
msgstr ""

msgid ""
"> Note: An interesting note regarding `if/2` and `unless/2` is that they are i"
"mplemented as macros in the language; they aren't special language constructs "
"as they would be in many languages. You can check the documentation and the so"
"urce of `if/2` in [the `Kernel` module docs](https://hexdocs.pm/elixir/Kernel."
"html). The `Kernel` module is also where operators like `+/2` and functions li"
"ke `is_function/2` are defined, all automatically imported and available in yo"
"ur code by default."
msgstr ""
"`if/2` と `unless/2` がマクロとして実行されることに関して興味深いところですが、他の多くの言語でもそうであるように、取り立てるほど特別な構"
"造ではありません。これらに関するドキュメントや `if/2` のソースは [the `Kernel` module docs](https://hexdoc"
"s.pm/elixir/Kernel.html) で確認できます。 `Kernel` モジュールには `+/2` のような演算子や `is_function"
"/2` といった関数も定義されており、すべて自動的にインポートされるので、あなたのコードはデフォルトでそれらを利用することができます。"

msgid "## `do/end` blocks"
msgstr ""

msgid ""
"At this point, we have learned four control structures: `case`, `cond`, `if`, "
"and `unless`, and they were all wrapped in `do/end` blocks. It happens we coul"
"d also write `if` as follows:"
msgstr ""
"ここまで `case`, `cond`, `if`, `unless` という4つの制御構造を学びましたが、これらはすべて `do/end` ブロックに包含"
"されていました。しかし、よくある書き方として `if` を以下のようにすることもできたのです。"

msgid ""
"```iex\n"
"iex> if true, do: 1 + 2\n"
"3\n"
"```"
msgstr ""

msgid ""
"Notice how the example above has a comma between `true` and `do:`, that's beca"
"use it is using Elixir's regular syntax where each argument is separated by a "
"comma. We say this syntax is using *keyword lists*. We can pass `else` using k"
"eywords too:"
msgstr ""
"注目して欲しいのは、どうしてこの例で `true` と `do:` の間にコンマが置かれているのかです。この理由は、各引数がコンマによって区切られなければい"
"けないという基本的な文法によります。つまり、この文法は *キーワードリスト* を使っているということなのです。キーワードに `else` を渡して使うことも"
"できます。"

msgid ""
"```iex\n"
"iex> if false, do: :this, else: :that\n"
":that\n"
"```"
msgstr ""

msgid ""
"`do/end` blocks are a syntactic convenience built on top of the keywords one. "
"That's why `do/end` blocks do not require a comma between the previous argumen"
"t and the block. They are useful exactly because they remove the verbosity whe"
"n writing blocks of code. These are equivalent:"
msgstr ""
"`do/end` ブロックは文法的な便宜です。では、なぜ `do/end` ブロックは前にある引数やブロックとの間にコンマを必要としないのでしょう。以下の二"
"つは同等になります。"

msgid ""
"```iex\n"
"iex> if true do\n"
"...>   a = 1 + 2\n"
"...>   a + 10\n"
"...> end\n"
"13\n"
"iex> if true, do: (\n"
"...>   a = 1 + 2\n"
"...>   a + 10\n"
"...> )\n"
"13\n"
"```"
msgstr ""

msgid ""
"One thing to keep in mind when using `do/end` blocks is they are always bound "
"to the outermost function call. For example, the following expression:"
msgstr ""
"`do/end` ブロックを使う場合にひとつ留意して欲しいのが、これらは一番外側で呼ばれた関数に対して働く点です。例えば以下の表現は、`if` のキーワード"
"としては認められません。"

msgid ""
"```iex\n"
"iex> is_number if true do\n"
"...>  1 + 2\n"
"...> end\n"
"** (CompileError) iex:1: undefined function is_number/2\n"
"```"
msgstr ""

msgid "Would be parsed as:"
msgstr "その為、実際には以下のように解釈されることになってしまいます。"

msgid ""
"```iex\n"
"iex> is_number(if true) do\n"
"...>  1 + 2\n"
"...> end\n"
"** (CompileError) iex:1: undefined function is_number/2\n"
"```"
msgstr ""

msgid ""
"which leads to an undefined function error because that invocation passes two "
"arguments, and `is_number/2` does not exist. The `if true` expression is inval"
"id in itself because it needs the block, but since the arity of `is_number/2` "
"does not match, Elixir does not even reach its evaluation."
msgstr ""
"無理なお願いをしたことで起こった undefined function のエラーです。 `is_number/2` は存在しないと言っています。`if tr"
"ue` という式はブロックが必要になる為、これ自体が無効な表現となります。 `is_number/2` のアリティとは一致しません。ゆえに Elixir は"
"それを評価するにさえ至らないのです。"

msgid "Adding explicit parentheses is enough to bind the block to `if`:"
msgstr "`if` にブロックを括り付けるには明確に丸括弧で囲むだけで十分です。"

msgid ""
"```iex\n"
"iex> is_number(if true do\n"
"...>  1 + 2\n"
"...> end)\n"
"true\n"
"```"
msgstr ""

msgid ""
"Keyword lists play an important role in the language and are quite common in m"
"any functions and macros. We will explore them a bit more in a future chapter."
" Now it is time to talk about \"Binaries, strings, and char lists\"."
msgstr ""
"キーワードリストはとても重要な役割を果たしており、多くの関数やマクロにおいて普遍的なものです。それについてはまた別の章で取り上げる事として、そろそろ \"バイ"
"ナリ、文字列、文字リスト\" の紹介してもいい頃でしょう。"
