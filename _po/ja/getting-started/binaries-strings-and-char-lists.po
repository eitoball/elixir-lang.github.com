msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2018-08-11 01:00+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: Binaries, strings, and charlists\n"
"---"
msgstr ""
"---\n"
"layout: getting-started\n"
"title: バイナリ、文字列、文字リスト\n"
"---"

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid ""
"In \"Basic types\", we learned about strings and used the `is_binary/1` function"
" for checks:"
msgstr "基本型の章で、我々は文字列について学び、`is_binary/1` 関数を使いました。"

msgid ""
"```iex\n"
"iex> string = \"hello\"\n"
"\"hello\"\n"
"iex> is_binary(string)\n"
"true\n"
"```"
msgstr ""

msgid ""
"In this chapter, we will understand what binaries are, how they associate with"
" strings, and what a single-quoted value, `'like this'`, means in Elixir."
msgstr ""
"Elixir におけるバイナリがどのように文字列と関連するのか、`'こういった単一引用符'` がどういう意味を持っているのか。この章では、バイナリについてそ"
"れが何であるかを理解していきましょう。"

msgid "## UTF-8 and Unicode"
msgstr "## UTF-8 と Unicode"

msgid ""
"A string is a UTF-8 encoded binary. In order to understand exactly what we mea"
"n by that, we need to understand the difference between bytes and code points."
msgstr "文字列は UTF-8 でエンコードされたバイナリです。この意味を理解する為には、バイトとコードポイントの違いを知る必要があります。"

msgid ""
"The Unicode standard assigns code points to many of the characters we know. Fo"
"r example, the letter `a` has code point `97` while the letter `ł` has code po"
"int `322`. When writing the string `\"hełło\"` to disk, we need to convert this "
"sequence of characters to bytes. If we adopted a rule that said one byte repre"
"sents one code point, we wouldn't be able to write `\"hełło\"`, because it uses "
"the code point `322` for `ł`, and one byte can only represent a number from `0"
"` to `255`. But of course, given you can actually read `\"hełło\"` on your scree"
"n, it must be represented *somehow*. That's where encodings come in."
msgstr ""
"Unicode は私たちが使う多くの文字にコードポイントを割り振っています。例えば、`a`という文字は`97`のコードポイントを持っていますが、`ł`という"
"文字は`322`のコードポイントを持っています。ディスクに`\"hełło\"`という文字列を書き込む際に、私たちはこれら文字の連なりをバイトに変換しなければな"
"らないのですが、1バイトが一つのコードポイントを表現するというルールに習った場合、`\"hełło\"`を表現することができません。コードポイント`322`は`"
"ł`の為に使用していますが、1バイトでは`0`から`255`の数値を表現することしかできないのです。とはいえ、実際には`\"hełło\"`をスクリーン上で読め"
"るのですから、 *何らかの方法* でそれを表現する必要があります。そこでエンコーディングの出番です。"

msgid ""
"When representing code points in bytes, we need to encode them somehow. Elixir"
" chose the UTF-8 encoding as its main and default encoding. When we say a stri"
"ng is a UTF-8 encoded binary, we mean a string is a bunch of bytes organized i"
"n a way to represent certain code points, as specified by the UTF-8 encoding."
msgstr ""
"バイトでコードポイントを表現する際にそれらをどうにかエンコードする必要があります。Elixir はデフォルトのエンコード方式として UTF-8 を採用してい"
"ます。文字列は UTF-8 でエンコードされたバイナリだと述べました。あの意味は、文字列が UTF-8 で指定された通りのコードポイントを表す為に編成される"
"バイトの一塊りだという意味です。"

msgid ""
"Since we have characters like `ł` assigned to the code point `322`, we actuall"
"y need more than one byte to represent them. That's why we see a difference wh"
"en we calculate the `byte_size/1` of a string compared to its `String.length/1"
"`:"
msgstr ""
"コードポイント `322` が割り振られている `ł` のような文字があるので、実際にはそれを表現する為に 1 バイト以上が必要になります。`String."
"length/1`と`byte_size/1`で比較し、違いを見てみます。"

msgid ""
"```iex\n"
"iex> string = \"hełło\"\n"
"\"hełło\"\n"
"iex> byte_size(string)\n"
"7\n"
"iex> String.length(string)\n"
"5\n"
"```"
msgstr ""

msgid ""
"There, `byte_size/1` counts the underlying raw bytes, and `String.length/1` co"
"unts characters."
msgstr "ほら。`byte_size/1`は根本的にバイト数を計算しますが、`String.length/1`は文字数を計算していますね。"

msgid ""
"> Note: if you are running on Windows, there is a chance your terminal does no"
"t use UTF-8 by default. You can change the encoding of your current session by"
" running `chcp 65001` before entering `iex` (`iex.bat`)."
msgstr ""
"Note: Windows ではターミナルがデフォルトで UTF-8 が使えないことがあります。`iex` (`iex.bat`)を起動する前に`chcp "
"65001`を実行して現在のセッションのエンコードを変更できます。"

msgid ""
"UTF-8 requires one byte to represent the characters `h`, `e`, and `o`, but two"
" bytes to represent `ł`. In Elixir, you can get a character's code point by us"
"ing `?`:"
msgstr ""
"UTF-8 は`h`、`e`、`o`を表現する為にそれぞれ 1 バイトを必要としますが、`ł`の表現には 2 バイトです。Elixir では `?` を使っ"
"て文字のコードポイントを得られます。"

msgid ""
"```iex\n"
"iex> ?a\n"
"97\n"
"iex> ?ł\n"
"322\n"
"```"
msgstr ""

msgid ""
"You can also use the functions in [the `String` module](https://hexdocs.pm/eli"
"xir/String.html) to split a string in its individual characters, each one as a"
" string of length 1:"
msgstr ""
"[the `String` module](https://hexdocs.pm/elixir/String.html)の関数を使ってそれぞれを一文字の長さ"
"に分割できます。"

msgid ""
"```iex\n"
"iex> String.codepoints(\"hełło\")\n"
"[\"h\", \"e\", \"ł\", \"ł\", \"o\"]\n"
"```"
msgstr ""

msgid ""
"You will see that Elixir has excellent support for working with strings. It al"
"so supports many of the Unicode operations. In fact, Elixir passes all the tes"
"ts showcased in the article [\"The string type is broken\"](http://mortoray.com/"
"2013/11/27/the-string-type-is-broken/)."
msgstr ""
"Elixir が優れた文字列操作をサポートしていることをお分かりいただけると思います。また同時に多くの Unicode 操作もサポートしています。実際、[\""
"文字列型は壊れている(英語)\"](http://mortoray.com/2013/11/27/the-string-type-is-broken/)という"
"記事で提示されているすべてのテストを Elixir はパスしています。"

msgid ""
"However, strings are just part of the story. If a string is a binary, and we h"
"ave used the `is_binary/1` function, Elixir must have an underlying type empow"
"ering strings. And it does! Let's talk about binaries."
msgstr ""
"しかし、文字列型はこの話におけるほんの一部分にでしかありません。文字列がバイナリであり、`is_binary/1`関数を使った時、Elixir には文字列を"
"強化する為に基礎的な型が必要です。というわけで、それをやるとしましょう。今こそバイナリについてお話する時です！"

msgid "## Binaries (and bitstrings)"
msgstr "## バイナリとビット文字列"

msgid "In Elixir, you can define a binary using `<<>>`:"
msgstr "Elixir では `<<>>` を使ってバイナリを定義できます。"

msgid ""
"```iex\n"
"iex> <<0, 1, 2, 3>>\n"
"<<0, 1, 2, 3>>\n"
"iex> byte_size(<<0, 1, 2, 3>>)\n"
"4\n"
"```"
msgstr ""

msgid ""
"A binary is a sequence of bytes. Those bytes can be organized in any way, even"
" in a sequence that does not make them a valid string:"
msgstr "バイナリとはバイトのシーケンスです。これらのバイトは、どのような方法でも、文字列としては不正なシーケンスにさえ編成され得ます。"

msgid ""
"```iex\n"
"iex> String.valid?(<<239, 191, 19>>)\n"
"false\n"
"```"
msgstr ""

msgid ""
"The string concatenation operation is actually a binary concatenation operator"
":"
msgstr "文字列の連結操作は、実際にはバイナリの連結操作です。"

msgid ""
"```iex\n"
"iex> <<0, 1>> <> <<2, 3>>\n"
"<<0, 1, 2, 3>>\n"
"```"
msgstr ""

msgid ""
"A common trick in Elixir is to concatenate the null byte `<<0>>` to a string t"
"o see its inner binary representation:"
msgstr "Elixir では、文字列の内部的なバイナリ表現を確かめる為に空のバイト `<<0>>`` を連結させるというテクニックをよく使います。"

msgid ""
"```iex\n"
"iex> \"hełło\" <> <<0>>\n"
"<<104, 101, 197, 130, 197, 130, 111, 0>>\n"
"```"
msgstr ""

msgid ""
"Each number given to a binary is meant to represent a byte and therefore must "
"go up to 255. Binaries allow modifiers to be given to store numbers bigger tha"
"n 255 or to convert a code point to its UTF-8 representation:"
msgstr ""
"バイナリに与えたれている各数字はバイトを表す為であり、255 以下でなければいけません。バイナリは 255 より大きな数字を保持したり、コードポイントを U"
"TF-8 に変換する為に修飾子を受け付けることができます。"

msgid ""
"```iex\n"
"iex> <<255>>\n"
"<<255>>\n"
"iex> <<256>> # truncated\n"
"<<0>>\n"
"iex> <<256 :: size(16)>> # use 16 bits (2 bytes) to store the number\n"
"<<1, 0>>\n"
"iex> <<256 :: utf8>> # the number is a code point\n"
"\"Ā\"\n"
"iex> <<256 :: utf8, 0>>\n"
"<<196, 128, 0>>\n"
"```"
msgstr ""

msgid "If a byte has 8 bits, what happens if we pass a size of 1 bit?"
msgstr "1byte(8bit) に 1bit を渡すとどうなるでしょうか。"

msgid ""
"```iex\n"
"iex> <<1 :: size(1)>>\n"
"<<1::size(1)>>\n"
"iex> <<2 :: size(1)>> # truncated\n"
"<<0::size(1)>>\n"
"iex> is_binary(<<1 :: size(1)>>)\n"
"false\n"
"iex> is_bitstring(<<1 :: size(1)>>)\n"
"true\n"
"iex> bit_size(<<1 :: size(1)>>)\n"
"1\n"
"```"
msgstr ""

msgid ""
"The value is no longer a binary, but a bitstring -- a bunch of bits! So a bina"
"ry is a bitstring where the number of bits is divisible by 8."
msgstr "値はもはやバイナリではありませんが、ビット文字列、つまりビットの塊です。よって、バイナリはビット数が 8 で割り切ることのできるビット文字列です。"

msgid ""
"```iex\n"
"iex>  is_binary(<<1 :: size(16)>>)\n"
"true\n"
"iex>  is_binary(<<1 :: size(15)>>)\n"
"false\n"
"```"
msgstr ""

msgid "We can also pattern match on binaries / bitstrings:"
msgstr "バイナリやビット文字列でもパターンマッチができます。"

msgid ""
"```iex\n"
"iex> <<0, 1, x>> = <<0, 1, 2>>\n"
"<<0, 1, 2>>\n"
"iex> x\n"
"2\n"
"iex> <<0, 1, x>> = <<0, 1, 2, 3>>\n"
"** (MatchError) no match of right hand side value: <<0, 1, 2, 3>>\n"
"```"
msgstr ""

msgid ""
"Note each entry in the binary pattern is expected to match exactly 8 bits. If "
"we want to match on a binary of unknown size, it is possible by using the bina"
"ry modifier at the end of the pattern:"
msgstr ""
"バイナリパターンの各エントリはちょうど 8bit にマッチすることを期待されています。サイズが分からないバイナリでマッチさせたい時には、パターンマッチの最後"
"にバイナリ修飾子を置くことによって可能です。"

msgid ""
"```iex\n"
"iex> <<0, 1, x :: binary>> = <<0, 1, 2, 3>>\n"
"<<0, 1, 2, 3>>\n"
"iex> x\n"
"<<2, 3>>\n"
"```"
msgstr ""

msgid "Similar results can be achieved with the string concatenation operator `<>`:"
msgstr "文字列の連結演算子を使って、類似する結果を得ることができます。"

msgid ""
"```iex\n"
"iex> \"he\" <> rest = \"hello\"\n"
"\"hello\"\n"
"iex> rest\n"
"\"llo\"\n"
"```"
msgstr ""

msgid ""
"A complete reference about the binary / bitstring constructor `<<>>` can be fo"
"und [in the Elixir documentation](https://hexdocs.pm/elixir/Kernel.SpecialForm"
"s.html#%3C%3C%3E%3E/1). This concludes our tour of bitstrings, binaries and st"
"rings. A string is a UTF-8 encoded binary and a binary is a bitstring where th"
"e number of bits is divisible by 8. Although this shows the flexibility Elixir"
" provides for working with bits and bytes, 99% of the time you will be working"
" with binaries and using the `is_binary/1` and `byte_size/1` functions."
msgstr ""
"バイナリとビット文字列のコンストラクタに関する詳細な資料は[in the Elixir documentation](https://hexdocs.pm/"
"elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1)を参照してください。これにて文字列、バイナリ、ビット文字列のツ"
"アーは終了します。文字列とは UTF-8 でエンコードされたバイナリであり、バイナリとはビット数が 8 で割り切ることのできるビット文字列でした。ここで E"
"lixir がビットとバイトを用いた作業の為の柔軟性が用意されていることを示しましたが、99% はバイナリ操作と `is_binary/1` と `byte"
"_size/1` を使うことになります。"

msgid "## Charlists"
msgstr "## 文字リスト"

msgid ""
"A charlist is nothing more than a list of code points. Char lists may be creat"
"ed with single-quoted literals:"
msgstr "文字リストとはコードポイントのリストにすぎません。文字リストはシングルクォーテーションを使ったリテラルで作成できます。"

msgid ""
"```iex\n"
"iex> 'hełło'\n"
"[104, 101, 322, 322, 111]\n"
"iex> is_list 'hełło'\n"
"true\n"
"iex> 'hello'\n"
"'hello'\n"
"iex> List.first('hello')\n"
"104\n"
"```"
msgstr ""

msgid ""
"You can see that, instead of containing bytes, a charlist contains the code po"
"ints of the characters between single-quotes (note that by default IEx will on"
"ly output code points if any of the integers is outside the ASCII range). So w"
"hile double-quotes represent a string (i.e. a binary), single-quotes represent"
" a charlist (i.e. a list)."
msgstr ""
"文字リストはバイトの代わりに文字のコードポイントを包含していることが分かりますね (IEx は、いずれかの整数が ASCII の範囲を超える場合のみ、デフォ"
"ルトでコードポイントを出力します)。ダブルクォーテーションが文字列(i.e. バイナリ) を表現するのに対して、シングルクォーテーションは文字リストを表現し"
"ます(i.e. リスト)。"

msgid ""
"In practice, charlists are used mostly when interfacing with Erlang, in partic"
"ular old libraries that do not accept binaries as arguments. You can convert a"
" charlist to a string and back by using the `to_string/1` and `to_charlist/1` "
"functions:"
msgstr 実際には、文字リストは特に引数としてバイナリを受け付けない古いErlangライブラリとの、インターフェイスとして使われます。 `to_string/1` や `to_charlist/1` 関数を使って、文字リストを文字列に変換したり、文字列から文字リストに変換したりできます。

msgid ""
"```iex\n"
"iex> to_charlist \"hełło\"\n"
"[104, 101, 322, 322, 111]\n"
"iex> to_string 'hełło'\n"
"\"hełło\"\n"
"iex> to_string :hello\n"
"\"hello\"\n"
"iex> to_string 1\n"
"\"1\"\n"
"```"
msgstr ""

msgid ""
"Note that those functions are polymorphic. They not only convert charlists to "
"strings, but also integers to strings, atoms to strings, and so on."
msgstr "これらの関数は多態的に機能します。文字リストを文字列に変換するだけでなく、整数を文字列に変換したり、アトムを文字列に変換することもできます。"

msgid ""
"String (binary) concatenation uses the `<>` operator but charlists use the lis"
"ts concatenation operator `++`:"
msgstr "文字列 (バイナリ) 連結では `<>` を使いますが、文字リストにはリスト連結の `++` を使います。"

msgid ""
"```iex\n"
"iex> 'this ' <> 'fails'\n"
"** (CompileError) iex:2: invalid literal 'this ' in <<>>\n"
"    (elixir) src/elixir_bitstring.erl:19: :elixir_bitstring.expand/6\n"
"    (elixir) src/elixir_bitstring.erl:12: :elixir_bitstring.expand/4\n"
"    (elixir) expanding macro: Kernel.<>/2\n"
"    iex:2: (file)\n"
"iex> 'this ' ++ 'works'\n"
"'this works'\n"
"iex> \"he\" ++ \"llo\"\n"
"** (ArgumentError) argument error\n"
"    :erlang.++(\"he\", \"llo\")\n"
"iex> \"he\" <> \"llo\"\n"
"\"hello\"\n"
"```"
msgstr ""

msgid ""
"With binaries, strings, and charlists out of the way, it is time to talk about"
" key-value data structures."
msgstr "バイナリ、文字列、文字リストについてはこのくらいにして、続いてはキーと値のデータ構造についてお話ししましょう。"
