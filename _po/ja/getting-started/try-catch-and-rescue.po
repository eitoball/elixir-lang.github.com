msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2018-08-11 01:00+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: try, catch, and rescue\n"
"---"
msgstr ""
"---\n"
"layout: getting-started\n"
"title: try、catch、rescue\n"
"---"

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid ""
"Elixir has three error mechanisms: errors, throws, and exits. In this chapter,"
" we will explore each of them and include remarks about when each should be us"
"ed."
msgstr "Elixir は3つのエラー機構を持っています。エラー、スロー、イグジットです。この章では、それらがいつ使われるべきかをみていきましょう。"

msgid "## Errors"
msgstr "## エラー"

msgid ""
"Errors (or *exceptions*) are used when exceptional things happen in the code. "
"A sample error can be retrieved by trying to add a number into an atom:"
msgstr "エラー（または例外）はコード内で予期しない出来事が起きた時に使われます。例えば数値をアトムに加えようとした時に、エラーを発生させることが出来ます。"

msgid ""
"```iex\n"
"iex> :foo + 1\n"
"** (ArithmeticError) bad argument in arithmetic expression\n"
"     :erlang.+(:foo, 1)\n"
"```"
msgstr ""

msgid "A runtime error can be raised any time by using `raise/1`:"
msgstr "ランタイムエラーは `raise/1` を使うことでいつでも発生させることが出来ます。"

msgid ""
"```iex\n"
"iex> raise \"oops\"\n"
"** (RuntimeError) oops\n"
"```"
msgstr ""

msgid ""
"Other errors can be raised with `raise/2` passing the error name and a list of"
" keyword arguments:"
msgstr "それ以外のエラーは `raise/2` にエラー名とキーワード引数のリストを渡すことで発生させることが出来ます。"

msgid ""
"```iex\n"
"iex> raise ArgumentError, message: \"invalid argument foo\"\n"
"** (ArgumentError) invalid argument foo\n"
"```"
msgstr ""

msgid ""
"You can also define your own errors by creating a module and using the `defexc"
"eption` construct inside it; this way, you'll create an error with the same na"
"me as the module it's defined in. The most common case is to define a custom e"
"xception with a message field:"
msgstr ""
"モジュールを作り、その中で `defexception/1` マクロを使うことで、独自のエラーを定義することもできます。この方法では、モジュールと同じ名前の"
"エラーを作ることが出来ます。最も一般的な使用法は、独自のメッセージ付きエラーを定義することです。"

msgid ""
"```iex\n"
"iex> defmodule MyError do\n"
"iex>   defexception message: \"default message\"\n"
"iex> end\n"
"iex> raise MyError\n"
"** (MyError) default message\n"
"iex> raise MyError, message: \"custom message\"\n"
"** (MyError) custom message\n"
"```"
msgstr ""

msgid "Errors can be **rescued** using the `try/rescue` construct:"
msgstr "エラーは `tru/rescue` 構造を用いることで **捕捉** することが出来ます。"

msgid ""
"```iex\n"
"iex> try do\n"
"...>   raise \"oops\"\n"
"...> rescue\n"
"...>   e in RuntimeError -> e\n"
"...> end\n"
"%RuntimeError{message: \"oops\"}\n"
"```"
msgstr ""

msgid ""
"The example above rescues the runtime error and returns the error itself which"
" is then printed in the `iex` session."
msgstr "上の例ではランタイムエラーを補足し、 `ies` セッション内でエラーが表示されるように、そのエラー自身を返しています。"

msgid "If you don't have any use for the error, you don't have to provide it:"
msgstr "もしエラーを使う必要がないのであれば、エラー自身を返す必要はありません。"

msgid ""
"```iex\n"
"iex> try do\n"
"...>   raise \"oops\"\n"
"...> rescue\n"
"...>   RuntimeError -> \"Error!\"\n"
"...> end\n"
"\"Error!\"\n"
"```"
msgstr ""

msgid ""
"In practice, however, Elixir developers rarely use the `try/rescue` construct."
" For example, many languages would force you to rescue an error when a file ca"
"nnot be opened successfully. Elixir instead provides a `File.read/1` function "
"which returns a tuple containing information about whether the file was opened"
" successfully:"
msgstr ""
"しかし実際のところ、Elixirで開発中に `try/rescue` 構造を使うことはほとんどないでしょう。例えば、多くの言語ではファイルを開けなかったとき"
"にエラーになるので、あなたがそれを捕捉しなければならないようになっています。一方Elixirが提供する `File.read/1` 関数は、ファイルを開くこ"
"とに成功したかどうかの情報を含んだタプルを返します。"

msgid ""
"```iex\n"
"iex> File.read \"hello\"\n"
"{:error, :enoent}\n"
"iex> File.write \"hello\", \"world\"\n"
":ok\n"
"iex> File.read \"hello\"\n"
"{:ok, \"world\"}\n"
"```"
msgstr ""

msgid ""
"There is no `try/rescue` here. In case you want to handle multiple outcomes of"
" opening a file, you can use pattern matching within the `case` construct:"
msgstr ""
"そこに `try/rescue` は存在しません。ファイルを開く時の複数の結果を取り扱いたい場合は、 `case` 構造と一緒にパターンマッチングを使うこと"
"が出来ます。"

msgid ""
"```iex\n"
"iex> case File.read \"hello\" do\n"
"...>   {:ok, body}      -> IO.puts \"Success: #{body}\"\n"
"...>   {:error, reason} -> IO.puts \"Error: #{reason}\"\n"
"...> end\n"
"```"
msgstr ""

msgid ""
"At the end of the day, it's up to your application to decide if an error while"
" opening a file is exceptional or not. That's why Elixir doesn't impose except"
"ions on `File.read/1` and many other functions. Instead, it leaves it up to th"
"e developer to choose the best way to proceed."
msgstr ""
"要するに、ファイルを開くときのエラーが例外かそうでないかを決めるのはあなたのアプリケーション次第です。だからこそElixirは `File.read/1` "
"やその他の関数で例外を強制しません。その代りに、最も良い例外の処理方法を開発者に委ねます。"

msgid ""
"For the cases where you do expect a file to exist (and the lack of that file i"
"s truly an *error*) you may use `File.read!/1`:"
msgstr "ファイルが存在することを期待している時（そしてそのファイルが存在しないときは本当にエラーである時）、 `File.read!/1` を使うでしょう。"

msgid ""
"```iex\n"
"iex> File.read! \"unknown\"\n"
"** (File.Error) could not read file unknown: no such file or directory\n"
"    (elixir) lib/file.ex:272: File.read!/1\n"
"```"
msgstr ""

msgid ""
"Many functions in the standard library follow the pattern of having a counterp"
"art that raises an exception instead of returning tuples to match against. The"
" convention is to create a function (`foo`) which returns `{:ok, result}` or `"
"{:error, reason}` tuples and another function (`foo!`, same name but with a tr"
"ailing `!`) that takes the same arguments as `foo` but which raises an excepti"
"on if there's an error. `foo!` should return the result (not wrapped in a tupl"
"e) if everything goes fine. The [`File` module](https://hexdocs.pm/elixir/File"
".html) is a good example of this convention."
msgstr ""
"標準ライブラリ内の多くの関数は、マッチするタプルを返す代わりに例外を発生させる、という反対のパターンに従います。規約では、 `foo` 関数を作るときは `"
"{:ok, result}` か `{:error, reason}` タプルを返し、 `foo!` という、 `foo` と同じ名前に `!` がつき `"
"foo` と同じ引数を取る関数は、エラーが生じたときは例外を発生させます。 `foo!` はすべてが上手く行った時は、タプルで囲わない結果を返すべきです。 "
"[`File` モジュール](https://hexdocs.pm/elixir/File.html)  はこの規約についての良い例です。"

msgid ""
"In Elixir, we avoid using `try/rescue` because **we don't use errors for contr"
"ol flow**. We take errors literally: they are reserved for unexpected and/or e"
"xceptional situations. In case you actually need flow control constructs, *thr"
"ows* should be used. That's what we are going to see next."
msgstr ""
"Elixirでは、 `try/rescue` の使用を避けています。なぜなら、 **フローを制御するためにエラーを使わないから** です。私達はエラーを文字"
"通りに受け取ります。エラーは予期しないまたは予期した例外的状況のために用意されています。フローを制御する構造が必要な場合は、 *スロー* が使われるべきです"
"。それでは次にスローを見ていきましょう。"

msgid "## Throws"
msgstr "## スロー"

msgid ""
"In Elixir, a value can be thrown and later be caught. `throw` and `catch` are "
"reserved for situations where it is not possible to retrieve a value unless by"
" using `throw` and `catch`."
msgstr ""
"Elixirでは、ある値を投げ、後で捕まえることができます。`trhow` と `catch` を使わなければ値を取ることが出来ない状況のために、 `thr"
"ow` と `catch` は予約されています。"

msgid ""
"Those situations are quite uncommon in practice except when interfacing with l"
"ibraries that do not provide a proper API. For example, let's imagine the `Enu"
"m` module did not provide any API for finding a value and that we needed to fi"
"nd the first multiple of 13 in a list of numbers:"
msgstr ""
"それらの状況は、適切なAPIが提供されていないライブラリに直面しなければ、実際にはかなり珍しいことです。例えば、 `Enum` モジュールが値を探すためのA"
"PIを何一つ用意しておらず、数字のリストから最初の13の倍数を探す必要がある場合を想像してみてください。"

msgid ""
"```iex\n"
"iex> try do\n"
"...>   Enum.each -50..50, fn(x) ->\n"
"...>     if rem(x, 13) == 0, do: throw(x)\n"
"...>   end\n"
"...>   \"Got nothing\"\n"
"...> catch\n"
"...>   x -> \"Got #{x}\"\n"
"...> end\n"
"\"Got -39\"\n"
"```"
msgstr ""

msgid ""
"Since `Enum` *does* provide a proper API, in practice `Enum.find/2` is the way"
" to go:"
msgstr "`Enum` が適切なAPIを *提供している* のであれば、実際には `Enum.find/2` を使うのがベストです。"

msgid ""
"```iex\n"
"iex> Enum.find -50..50, &(rem(&1, 13) == 0)\n"
"-39\n"
"```"
msgstr ""

msgid "## Exits"
msgstr "## イグジット"

msgid ""
"All Elixir code runs inside processes that communicate with each other. When a"
" process dies of \"natural causes\" (e.g., unhandled exceptions), it sends an `e"
"xit` signal. A process can also die by explicitly sending an exit signal:"
msgstr ""
"すべてのElixirのコードは、お互いに通信をし合うプロセス群の中で動作します。プロセスが\"自然な原因\"（未処理の例外など）で死んだ時、プロセスは `exi"
"t` 信号を送ります。プロセスは明示的に `exit` 信号を送ることで殺すことも出来ます。"

msgid ""
"```iex\n"
"iex> spawn_link fn -> exit(1) end\n"
"** (EXIT from #PID<0.56.0>) evaluator process exited with reason: 1\n"
"```"
msgstr ""

msgid ""
"In the example above, the linked process died by sending an `exit` signal with"
" a value of 1. The Elixir shell automatically handles those messages and print"
"s them to the terminal."
msgstr ""
"上の例ではリンクしていたプロセスが、1という値と一緒に `exit` 信号が送られ、死にました。Elixirシェルは自動的にこれらのメッセージを処理し、ター"
"ミナル上に表示します。"

msgid "`exit` can also be \"caught\" using `try/catch`:"
msgstr "`exit` は `try/catch` を使うことで \"捕まえる\\"

msgid ""
"```iex\n"
"iex> try do\n"
"...>   exit \"I am exiting\"\n"
"...> catch\n"
"...>   :exit, _ -> \"not really\"\n"
"...> end\n"
"\"not really\"\n"
"```"
msgstr ""

msgid ""
"Using `try/catch` is already uncommon and using it to catch exits is even rare"
"r."
msgstr "`try/catch` を使うことは珍しく、それを使ってイグジットを捕まえることはさらに稀です。"

msgid ""
"`exit` signals are an important part of the fault tolerant system provided by "
"the Erlang <abbr title=\"Virtual Machine\">VM</abbr>. Processes usually run unde"
"r supervision trees which are themselves processes that listen to `exit` signa"
"ls from the supervised processes. Once an exit signal is received, the supervi"
"sion strategy kicks in and the supervised process is restarted."
msgstr ""
"`exit` 信号はErlang <abbr title=\"Virtual Machine\">VM</abbr> によって提供される耐障害性の重要な要素です"
"。プロセス群は通常、監視プロセス群からの `exit` 信号を待ち受けている、監視ツリーの元で動作します。ひとたび `exit` 信号を受け取ると、監視スト"
"ラテジーが実行に移され、監視されているプロセスは再起動されます。"

msgid ""
"It is exactly this supervision system that makes constructs like `try/catch` a"
"nd `try/rescue` so uncommon in Elixir. Instead of rescuing an error, we'd rath"
"er \"fail fast\" since the supervision tree will guarantee our application will "
"go back to a known initial state after the error."
msgstr ""
"Elixirで `try/catch` と `try/rescue` の構造を珍しくするのは、この監視の仕組のおかげです。エラーの後に既知の初期状態にアプリ"
"ケーションを戻してくれることを監視ツリーが保証してくれるので、エラーを救う代わりに、むしろ \"エラー時はただちにシステムを停止\" させるのです。"

msgid "## After"
msgstr "## アフター"

msgid ""
"Sometimes it's necessary to ensure that a resource is cleaned up after some ac"
"tion that could potentially raise an error. The `try/after` construct allows y"
"ou to do that. For example, we can open a file and use an `after` clause to cl"
"ose it--even if something goes wrong:"
msgstr ""
"潜在的にエラーを起こす可能性のあるアクションの後に、リソースが片付けられていることを確実にすることが、時々必要になります。 `try/after` 構造はそ"
"れをできるようにします。例えば、ファイルを開いた時に `after` 句を使って、失敗したとしてもファイルを閉じることができます。"

msgid ""
"```iex\n"
"iex> {:ok, file} = File.open \"sample\", [:utf8, :write]\n"
"iex> try do\n"
"...>   IO.write file, \"olá\"\n"
"...>   raise \"oops, something went wrong\"\n"
"...> after\n"
"...>   File.close(file)\n"
"...> end\n"
"** (RuntimeError) oops, something went wrong\n"
"```"
msgstr ""

msgid ""
"The `after` clause will be executed regardless of whether or not the tried blo"
"ck succeeds. Note, however, that if a linked process exits,\n"
"this process will exit and the `after` clause will not get run. Thus `after` p"
"rovides only a soft guarantee. Luckily, files in Elixir are also linked to the"
" current processes and therefore they will always get closed if the current pr"
"ocess crashes, independent of the\n"
"`after` clause. You will find the same to be true for other resources like ETS"
" tables, sockets, ports and more."
msgstr ""
"`after` 句は思考されたブロックが成功したかどうかに関わらず実行されます。しかしリンクされたプロセスが終了した場合は、\n"
"このプロセスが終了し `after` 句が実行されることはない、ということに注意してください。したがって、 `after` は簡易な保証しか提供しません。運"
"良くElixir内のファイルが現在のプロセス群にリンクされており、そのために現在のプロセスがクラッシュした時に常にファイルが閉じられたとしても、 \n"
"`after` 句とは別の話です。ETSテーブルやソケット、ポートなどその他のリソースについても同じことが言えます。"

msgid ""
"Sometimes you may want to wrap the entire body of a function in a `try` constr"
"uct, often to guarantee some code will be executed afterwards. In such cases, "
"Elixir allows you to omit the `try` line:"
msgstr ""
"時々、最後にいくつかのコードが実行されることを保証するために、関数内のすべてのコードを `try` 構造で囲みたいと思うかもしれません。そのような場合は、E"
"lixirでは `try` 行を省略することができます。"

msgid ""
"```iex\n"
"iex> defmodule RunAfter do\n"
"...>   def without_even_trying do\n"
"...>     raise \"oops\"\n"
"...>   after\n"
"...>     IO.puts \"cleaning up!\"\n"
"...>   end\n"
"...> end\n"
"iex> RunAfter.without_even_trying\n"
"cleaning up!\n"
"** (RuntimeError) oops\n"
"```"
msgstr ""

msgid ""
"Elixir will automatically wrap the function body in a `try` whenever one of `a"
"fter`, `rescue` or `catch` is specified."
msgstr "Elixirは `after`、`rescue`、`catch` のいずれかが指定されている時は、自動的に関数の本体を `try` で囲みます。"

msgid "## Else"
msgstr "## エルス"

msgid ""
"If an `else` block is present, it will match on the results of the `try` block"
" whenever the `try` block finishes without a throw or an error."
msgstr "`else` ブロックが存在する場合は、`try` ブロックがエラーもスローもなく終了する度に、`try` ブロックの結果とマッチします。"

msgid ""
"```iex\n"
"iex> x = 2\n"
"2\n"
"iex> try do\n"
"...>   1 / x\n"
"...> rescue\n"
"...>   ArithmeticError ->\n"
"...>     :infinity\n"
"...> else\n"
"...>   y when y < 1 and y > -1 ->\n"
"...>     :small\n"
"...>   _ ->\n"
"...>     :large\n"
"...> end\n"
":small\n"
"```"
msgstr ""

msgid ""
"Exceptions in the `else` block are not caught. If no pattern inside the `else`"
" block matches, an exception will be raised; this exception is not caught by t"
"he current `try/catch/rescue/after` block."
msgstr ""
"`else` ブロック内の例外は捕捉されません。`else` ブロック内のどのパターンともマッチしない場合、例外が起こされます。この例外は現在の `try/"
"catch/rescue/after` ブロックでは捕捉されません。"

msgid "## Variables scope"
msgstr "## 変数のスコープ"

msgid ""
"It is important to bear in mind that variables defined inside `try/catch/rescu"
"e/after` blocks do not leak to the outer context. This is because the `try` bl"
"ock may fail and as such the variables may never be bound in the first place. "
"In other words, this code is invalid:"
msgstr ""
"`try/catch/rescue/after` ブロックの中で定義された変数は、その外側のコンテキストに漏れることがないということを心に留めておいてくださ"
"い。`try` ブロックは失敗するかもしれず、ブロック内の変数がそもそも見つかることが無いかもしれないからです。この不正なコードの例で見てみましょう。"

msgid ""
"```iex\n"
"iex> try do\n"
"...>   raise \"fail\"\n"
"...>   what_happened = :did_not_raise\n"
"...> rescue\n"
"...>   _ -> what_happened = :rescued\n"
"...> end\n"
"iex> what_happened\n"
"** (RuntimeError) undefined function: what_happened/0\n"
"```"
msgstr ""

msgid "Instead, you can store the value of the `try` expression:"
msgstr "その代りに、`try` 式の値を保存することが出来ます。"

msgid ""
"```iex\n"
"iex> what_happened =\n"
"...>   try do\n"
"...>     raise \"fail\"\n"
"...>     :did_not_raise\n"
"...>   rescue\n"
"...>     _ -> :rescued\n"
"...>   end\n"
"iex> what_happened\n"
":rescued\n"
"```"
msgstr ""

msgid ""
"This finishes our introduction to `try`, `catch`, and `rescue`. You will find "
"they are used less frequently in Elixir than in other languages, although they"
" may be handy in some situations where a library or some particular code is no"
"t playing \"by the rules\"."
msgstr ""
"`try`、`catch`、`rescue` についての紹介はこれで終わりです。他の言語と比べてElixirでは、それらがそれほど頻繁に使われないことにあな"
"たは気づくでしょう。しかし、ライブラリや \"ルールに従っていない\" 一部のコードの中においては、役に立つかもしれません。"
