msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2018-08-11 01:00+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: try, catch, and rescue\n"
"---"
msgstr ""
"---\n"
"layout: getting-started\n"
"title: try、catch、rescue\n"
"---"

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid ""
"Elixir has three error mechanisms: errors, throws, and exits. In this chapter,"
" we will explore each of them and include remarks about when each should be us"
"ed."
msgstr "Elixir は3つのエラー機構を持っています。エラー、スロー、イグジットです。この章では、それらがいつ使われるべきかをみていきましょう。"

msgid "## Errors"
msgstr "## エラー"

msgid ""
"Errors (or *exceptions*) are used when exceptional things happen in the code. "
"A sample error can be retrieved by trying to add a number into an atom:"
msgstr "エラー（または例外）はコード内で予期しない出来事が起きた時に使われます。例えば数値をアトムに加えようとした時に、エラーを発生させることが出来ます。"

msgid ""
"```iex\n"
"iex> :foo + 1\n"
"** (ArithmeticError) bad argument in arithmetic expression\n"
"     :erlang.+(:foo, 1)\n"
"```"
msgstr ""

msgid "A runtime error can be raised any time by using `raise/1`:"
msgstr "ランタイムエラーは `raise/1` を使うことでいつでも発生させることが出来ます。"

msgid ""
"```iex\n"
"iex> raise \"oops\"\n"
"** (RuntimeError) oops\n"
"```"
msgstr ""

msgid ""
"Other errors can be raised with `raise/2` passing the error name and a list of"
" keyword arguments:"
msgstr "それ以外のエラーは `raise/2` にエラー名とキーワード引数のリストを渡すことで発生させることが出来ます。"

msgid ""
"```iex\n"
"iex> raise ArgumentError, message: \"invalid argument foo\"\n"
"** (ArgumentError) invalid argument foo\n"
"```"
msgstr ""

msgid ""
"You can also define your own errors by creating a module and using the `defexc"
"eption` construct inside it; this way, you'll create an error with the same na"
"me as the module it's defined in. The most common case is to define a custom e"
"xception with a message field:"
msgstr ""
"モジュールを作り、その中で `defexception/1` マクロを使うことで、独自のエラーを定義することもできます。この方法では、モジュールと同じ名前の"
"エラーを作ることが出来ます。最も一般的な使用法は、独自のメッセージ付きエラーを定義することです。"

msgid ""
"```iex\n"
"iex> defmodule MyError do\n"
"iex>   defexception message: \"default message\"\n"
"iex> end\n"
"iex> raise MyError\n"
"** (MyError) default message\n"
"iex> raise MyError, message: \"custom message\"\n"
"** (MyError) custom message\n"
"```"
msgstr ""

msgid "Errors can be **rescued** using the `try/rescue` construct:"
msgstr "エラーは `tru/rescue` 構造を用いることで **捕捉** することが出来ます。"

msgid ""
"```iex\n"
"iex> try do\n"
"...>   raise \"oops\"\n"
"...> rescue\n"
"...>   e in RuntimeError -> e\n"
"...> end\n"
"%RuntimeError{message: \"oops\"}\n"
"```"
msgstr ""

msgid ""
"The example above rescues the runtime error and returns the error itself which"
" is then printed in the `iex` session."
msgstr "上の例ではランタイムエラーを補足し、 `ies` セッション内でエラーが表示されるように、そのエラー自身を返しています。"

msgid "If you don't have any use for the error, you don't have to provide it:"
msgstr "もしエラーを使う必要がないのであれば、エラー自身を返す必要はありません。"

msgid ""
"```iex\n"
"iex> try do\n"
"...>   raise \"oops\"\n"
"...> rescue\n"
"...>   RuntimeError -> \"Error!\"\n"
"...> end\n"
"\"Error!\"\n"
"```"
msgstr ""

msgid ""
"In practice, however, Elixir developers rarely use the `try/rescue` construct."
" For example, many languages would force you to rescue an error when a file ca"
"nnot be opened successfully. Elixir instead provides a `File.read/1` function "
"which returns a tuple containing information about whether the file was opened"
" successfully:"
msgstr ""
"しかし実際のところ、Elixirで開発中に `try/rescue` 構造を使うことはほとんどないでしょう。例えば、多くの言語ではファイルを開けなかったとき"
"にエラーになるので、あなたがそれを捕捉しなければならないようになっています。一方Elixirが提供する `File.read/1` 関数は、ファイルを開くこ"
"とに成功したかどうかの情報を含んだタプルを返します。"

msgid ""
"```iex\n"
"iex> File.read \"hello\"\n"
"{:error, :enoent}\n"
"iex> File.write \"hello\", \"world\"\n"
":ok\n"
"iex> File.read \"hello\"\n"
"{:ok, \"world\"}\n"
"```"
msgstr ""

msgid ""
"There is no `try/rescue` here. In case you want to handle multiple outcomes of"
" opening a file, you can use pattern matching within the `case` construct:"
msgstr ""
"そこに `try/rescue` は存在しません。ファイルを開く時の複数の結果を取り扱いたい場合は、 `case` 構造と一緒にパターンマッチングを使うこと"
"が出来ます。"

msgid ""
"```iex\n"
"iex> case File.read \"hello\" do\n"
"...>   {:ok, body}      -> IO.puts \"Success: #{body}\"\n"
"...>   {:error, reason} -> IO.puts \"Error: #{reason}\"\n"
"...> end\n"
"```"
msgstr ""

msgid ""
"At the end of the day, it's up to your application to decide if an error while"
" opening a file is exceptional or not. That's why Elixir doesn't impose except"
"ions on `File.read/1` and many other functions. Instead, it leaves it up to th"
"e developer to choose the best way to proceed."
msgstr ""
"要するに、ファイルを開くときのエラーが例外かそうでないかを決めるのはあなたのアプリケーション次第です。だからこそElixirは `File.read/1` "
"やその他の関数で例外を強制しません。その代りに、最も良い例外の処理方法を開発者に委ねます。"

msgid ""
"For the cases where you do expect a file to exist (and the lack of that file i"
"s truly an *error*) you may use `File.read!/1`:"
msgstr "ファイルが存在することを期待している時（そしてそのファイルが存在しないときは本当にエラーである時）、 `File.read!/1` を使うでしょう。"

msgid ""
"```iex\n"
"iex> File.read! \"unknown\"\n"
"** (File.Error) could not read file unknown: no such file or directory\n"
"    (elixir) lib/file.ex:272: File.read!/1\n"
"```"
msgstr ""

msgid ""
"Many functions in the standard library follow the pattern of having a counterp"
"art that raises an exception instead of returning tuples to match against. The"
" convention is to create a function (`foo`) which returns `{:ok, result}` or `"
"{:error, reason}` tuples and another function (`foo!`, same name but with a tr"
"ailing `!`) that takes the same arguments as `foo` but which raises an excepti"
"on if there's an error. `foo!` should return the result (not wrapped in a tupl"
"e) if everything goes fine. The [`File` module](https://hexdocs.pm/elixir/File"
".html) is a good example of this convention."
msgstr ""
"標準ライブラリ内の多くの関数は、マッチするタプルを返す代わりに例外を発生させる、という反対のパターンに従います。規約では、 `foo` 関数を作るときは `"
"{:ok, result}` か `{:error, reason}` タプルを返し、 `foo!` という、 `foo` と同じ名前に `!` がつき `"
"foo` と同じ引数を取る関数は、エラーが生じたときは例外を発生させます。 `foo!` はすべてが上手く行った時は、タプルで囲わない結果を返すべきです。 "
"[`File` モジュール](https://hexdocs.pm/elixir/File.html)  はこの規約についての良い例です。"

msgid ""
"In Elixir, we avoid using `try/rescue` because **we don't use errors for contr"
"ol flow**. We take errors literally: they are reserved for unexpected and/or e"
"xceptional situations. In case you actually need flow control constructs, *thr"
"ows* should be used. That's what we are going to see next."
msgstr ""
"Elixirでは、 `try/rescue` の使用を避けています。なぜなら、 **フローを制御するためにエラーを使わないから** です。私達はエラーを文字"
"通りに受け取ります。エラーは予期しないまたは予期した例外的状況のために用意されています。フローを制御する構造が必要な場合は、 *スロー* が使われるべきです"
"。それでは次にスローを見ていきましょう。"

msgid "## Throws"
msgstr ""

msgid ""
"In Elixir, a value can be thrown and later be caught. `throw` and `catch` are "
"reserved for situations where it is not possible to retrieve a value unless by"
" using `throw` and `catch`."
msgstr ""

msgid ""
"Those situations are quite uncommon in practice except when interfacing with l"
"ibraries that do not provide a proper API. For example, let's imagine the `Enu"
"m` module did not provide any API for finding a value and that we needed to fi"
"nd the first multiple of 13 in a list of numbers:"
msgstr ""

msgid ""
"```iex\n"
"iex> try do\n"
"...>   Enum.each -50..50, fn(x) ->\n"
"...>     if rem(x, 13) == 0, do: throw(x)\n"
"...>   end\n"
"...>   \"Got nothing\"\n"
"...> catch\n"
"...>   x -> \"Got #{x}\"\n"
"...> end\n"
"\"Got -39\"\n"
"```"
msgstr ""

msgid ""
"Since `Enum` *does* provide a proper API, in practice `Enum.find/2` is the way"
" to go:"
msgstr ""

msgid ""
"```iex\n"
"iex> Enum.find -50..50, &(rem(&1, 13) == 0)\n"
"-39\n"
"```"
msgstr ""

msgid "## Exits"
msgstr ""

msgid ""
"All Elixir code runs inside processes that communicate with each other. When a"
" process dies of \"natural causes\" (e.g., unhandled exceptions), it sends an `e"
"xit` signal. A process can also die by explicitly sending an exit signal:"
msgstr ""

msgid ""
"```iex\n"
"iex> spawn_link fn -> exit(1) end\n"
"** (EXIT from #PID<0.56.0>) evaluator process exited with reason: 1\n"
"```"
msgstr ""

msgid ""
"In the example above, the linked process died by sending an `exit` signal with"
" a value of 1. The Elixir shell automatically handles those messages and print"
"s them to the terminal."
msgstr ""

msgid "`exit` can also be \"caught\" using `try/catch`:"
msgstr ""

msgid ""
"```iex\n"
"iex> try do\n"
"...>   exit \"I am exiting\"\n"
"...> catch\n"
"...>   :exit, _ -> \"not really\"\n"
"...> end\n"
"\"not really\"\n"
"```"
msgstr ""

msgid ""
"Using `try/catch` is already uncommon and using it to catch exits is even rare"
"r."
msgstr ""

msgid ""
"`exit` signals are an important part of the fault tolerant system provided by "
"the Erlang <abbr title=\"Virtual Machine\">VM</abbr>. Processes usually run unde"
"r supervision trees which are themselves processes that listen to `exit` signa"
"ls from the supervised processes. Once an exit signal is received, the supervi"
"sion strategy kicks in and the supervised process is restarted."
msgstr ""

msgid ""
"It is exactly this supervision system that makes constructs like `try/catch` a"
"nd `try/rescue` so uncommon in Elixir. Instead of rescuing an error, we'd rath"
"er \"fail fast\" since the supervision tree will guarantee our application will "
"go back to a known initial state after the error."
msgstr ""

msgid "## After"
msgstr ""

msgid ""
"Sometimes it's necessary to ensure that a resource is cleaned up after some ac"
"tion that could potentially raise an error. The `try/after` construct allows y"
"ou to do that. For example, we can open a file and use an `after` clause to cl"
"ose it--even if something goes wrong:"
msgstr ""

msgid ""
"```iex\n"
"iex> {:ok, file} = File.open \"sample\", [:utf8, :write]\n"
"iex> try do\n"
"...>   IO.write file, \"olá\"\n"
"...>   raise \"oops, something went wrong\"\n"
"...> after\n"
"...>   File.close(file)\n"
"...> end\n"
"** (RuntimeError) oops, something went wrong\n"
"```"
msgstr ""

msgid ""
"The `after` clause will be executed regardless of whether or not the tried blo"
"ck succeeds. Note, however, that if a linked process exits,\n"
"this process will exit and the `after` clause will not get run. Thus `after` p"
"rovides only a soft guarantee. Luckily, files in Elixir are also linked to the"
" current processes and therefore they will always get closed if the current pr"
"ocess crashes, independent of the\n"
"`after` clause. You will find the same to be true for other resources like ETS"
" tables, sockets, ports and more."
msgstr ""

msgid ""
"Sometimes you may want to wrap the entire body of a function in a `try` constr"
"uct, often to guarantee some code will be executed afterwards. In such cases, "
"Elixir allows you to omit the `try` line:"
msgstr ""

msgid ""
"```iex\n"
"iex> defmodule RunAfter do\n"
"...>   def without_even_trying do\n"
"...>     raise \"oops\"\n"
"...>   after\n"
"...>     IO.puts \"cleaning up!\"\n"
"...>   end\n"
"...> end\n"
"iex> RunAfter.without_even_trying\n"
"cleaning up!\n"
"** (RuntimeError) oops\n"
"```"
msgstr ""

msgid ""
"Elixir will automatically wrap the function body in a `try` whenever one of `a"
"fter`, `rescue` or `catch` is specified."
msgstr ""

msgid "## Else"
msgstr ""

msgid ""
"If an `else` block is present, it will match on the results of the `try` block"
" whenever the `try` block finishes without a throw or an error."
msgstr ""

msgid ""
"```iex\n"
"iex> x = 2\n"
"2\n"
"iex> try do\n"
"...>   1 / x\n"
"...> rescue\n"
"...>   ArithmeticError ->\n"
"...>     :infinity\n"
"...> else\n"
"...>   y when y < 1 and y > -1 ->\n"
"...>     :small\n"
"...>   _ ->\n"
"...>     :large\n"
"...> end\n"
":small\n"
"```"
msgstr ""

msgid ""
"Exceptions in the `else` block are not caught. If no pattern inside the `else`"
" block matches, an exception will be raised; this exception is not caught by t"
"he current `try/catch/rescue/after` block."
msgstr ""

msgid "## Variables scope"
msgstr ""

msgid ""
"It is important to bear in mind that variables defined inside `try/catch/rescu"
"e/after` blocks do not leak to the outer context. This is because the `try` bl"
"ock may fail and as such the variables may never be bound in the first place. "
"In other words, this code is invalid:"
msgstr ""

msgid ""
"```iex\n"
"iex> try do\n"
"...>   raise \"fail\"\n"
"...>   what_happened = :did_not_raise\n"
"...> rescue\n"
"...>   _ -> what_happened = :rescued\n"
"...> end\n"
"iex> what_happened\n"
"** (RuntimeError) undefined function: what_happened/0\n"
"```"
msgstr ""

msgid "Instead, you can store the value of the `try` expression:"
msgstr ""

msgid ""
"```iex\n"
"iex> what_happened =\n"
"...>   try do\n"
"...>     raise \"fail\"\n"
"...>     :did_not_raise\n"
"...>   rescue\n"
"...>     _ -> :rescued\n"
"...>   end\n"
"iex> what_happened\n"
":rescued\n"
"```"
msgstr ""

msgid ""
"This finishes our introduction to `try`, `catch`, and `rescue`. You will find "
"they are used less frequently in Elixir than in other languages, although they"
" may be handy in some situations where a library or some particular code is no"
"t playing \"by the rules\"."
msgstr ""
