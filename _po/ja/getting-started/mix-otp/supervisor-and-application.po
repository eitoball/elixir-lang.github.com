msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2017-10-30 15:10+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: Supervisor and Application\n"
"---"
msgstr ""

msgid "# {{ page.title }}"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid "{% include mix-otp-preface.html %}"
msgstr ""

msgid ""
"So far our application has a registry that may monitor dozens, if not hundreds"
", of buckets. While we think our implementation so far is quite good, no softw"
"are is bug free, and failures are definitely going to happen."
msgstr ""

msgid ""
"When things fail, your first reaction may be: \"let's rescue those errors\". But"
" in Elixir we avoid the defensive programming habit of rescuing exceptions. In"
"stead, we say \"let it crash\". If there is a bug that leads our registry to cra"
"sh, we have nothing to worry about because we are going to set up a supervisor"
" that will start a fresh copy of the registry."
msgstr ""

msgid ""
"In this chapter, we are going to learn about supervisors and also about applic"
"ations. We are going to create not one, but two supervisors, and use them to s"
"upervise our processes."
msgstr ""

msgid "## Our first supervisor"
msgstr ""

msgid ""
"Creating a supervisor is not much different from creating a GenServer. We are "
"going to define a module named `KV.Supervisor`, which will use the [Supervisor"
"](https://hexdocs.pm/elixir/Supervisor.html) behaviour, inside the `lib/kv/sup"
"ervisor.ex` file:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule KV.Supervisor do\n"
"  use Supervisor"
msgstr ""

msgid ""
"  def start_link(opts) do\n"
"    Supervisor.start_link(__MODULE__, :ok, opts)\n"
"  end"
msgstr ""

msgid ""
"  def init(:ok) do\n"
"    children = [\n"
"      KV.Registry\n"
"    ]"
msgstr ""

msgid ""
"    Supervisor.init(children, strategy: :one_for_one)\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"Our supervisor has a single child so far: `KV.Registry`. After we define a lis"
"t of children, we call `Supervisor.init/2`, passing the children and the super"
"vision strategy."
msgstr ""

msgid ""
"The supervision strategy dictates what happens when one of the children crashe"
"s. `:one_for_one` means that if a child dies, it will be the only one restarte"
"d. Since we have only one child now, that's all we need. The `Supervisor` beha"
"viour supports many different strategies and we will discuss them in this chap"
"ter."
msgstr ""

msgid ""
"Once the supervisor starts, it will traverse the list of children and it will "
"invoke the `child_spec/1` function on each module. We heard about the `child_s"
"pec/1` function in the Agent chapter, when we called `start_supervised(KV.Buck"
"et)` without defining the module."
msgstr ""

msgid ""
"The `child_spec/1` function returns the child specification which describes ho"
"w to start the process, if the process is a worker or a supervisor, if the pro"
"cess is temporary, transient or permanent and so on. The `child_spec/1` functi"
"on is automatically defined when we `use Agent`, `use GenServer`, `use Supervi"
"sor`, etc. Let's give it a try in the terminal with `iex -S mix`:"
msgstr ""

msgid ""
"```iex\n"
"iex(1)> KV.Registry.child_spec([])\n"
"%{\n"
"  id: KV.Registry,\n"
"  restart: :permanent,\n"
"  shutdown: 5000,\n"
"  start: {KV.Registry, :start_link, [[]]},\n"
"  type: :worker\n"
"}\n"
"```"
msgstr ""

msgid ""
"We will learn those details as we move forward on this guide. If you would rat"
"her peek ahead, check the [Supervisor](https://hexdocs.pm/elixir/Supervisor.ht"
"ml) docs."
msgstr ""

msgid ""
"After the supervisor retrieves all child specifications, it proceeds to start "
"its children one by one, in the order they were defined, using the information"
" in the `:start` key in the child specification. For our current specification"
", it will call `KV.Registry.start_link([])`."
msgstr ""

msgid ""
"So far `start_link/1` has always receive an empty list of options. It is time "
"we change that."
msgstr ""

msgid "## Naming processes"
msgstr ""

msgid ""
"While our application will have many buckets, it will only have a single regis"
"try. So instead of always passing the registry PID around, we can give the reg"
"istry a name, and always reference it by its name."
msgstr ""

msgid ""
"Also, remember buckets were started dynamically based on user input, and that "
"meant we should not use atom names for managing our buckets. But the registry "
"is in the opposite situation, we want to start a single registry, preferrably "
"under a supervisor, when our application boots."
msgstr ""

msgid ""
"So let's do that. Let's slightly change our children definition to be a list o"
"f tuples instead of a list of atoms:"
msgstr ""

msgid ""
"```elixir\n"
"  def init(:ok) do\n"
"    children = [\n"
"      {KV.Registry, name: KV.Registry}\n"
"    ]"
msgstr ""

msgid ""
"    Supervisor.init(children, strategy: :one_for_one)\n"
"  end\n"
"```"
msgstr ""

msgid ""
"The difference now is that, instead of calling `KV.Registry.start_link([])`, t"
"he Supervisor will call `KV.Registry.start_link([name: KV.Registry])`. If you "
"revisit `KV.Registry.start_link/1` implementation, you will remember it simply"
" passes the options to GenServer"
msgstr ""

msgid ""
"```elixir\n"
"  def start_link(opts) do\n"
"    GenServer.start_link(__MODULE__, :ok, opts)\n"
"  end\n"
"```"
msgstr ""

msgid "which in turn will register the process with the given name."
msgstr ""

msgid "Let's give this all a try inside `iex -S mix`:"
msgstr ""

msgid ""
"```iex\n"
"iex> KV.Supervisor.start_link([])\n"
"{:ok, #PID<0.66.0>}\n"
"iex> KV.Registry.create(KV.Registry, \"shopping\")\n"
":ok\n"
"iex> KV.Registry.lookup(KV.Registry, \"shopping\")\n"
"{:ok, #PID<0.70.0>}\n"
"```"
msgstr ""

msgid ""
"When we started the supervisor, the registry was automatically started with th"
"e given name, allowing us to create buckets without the need to manually start"
" it."
msgstr ""

msgid ""
"In practice we rarely start the application supervisor manually. Instead it is"
" started as part of the application callback."
msgstr ""

msgid "## Understanding applications"
msgstr ""

msgid ""
"We have been working inside an application this entire time. Every time we cha"
"nged a file and ran `mix compile`, we could see a `Generated kv app` message i"
"n the compilation output."
msgstr ""

msgid ""
"We can find the generated `.app` file at `_build/dev/lib/kv/ebin/kv.app`. Let'"
"s have a look at its contents:"
msgstr ""

msgid ""
"```erlang\n"
"{application,kv,\n"
"             [{registered,[]},\n"
"              {description,\"kv\"},\n"
"              {applications,[kernel,stdlib,elixir,logger]},\n"
"              {vsn,\"0.0.1\"},\n"
"              {modules,['Elixir.KV','Elixir.KV.Bucket',\n"
"                        'Elixir.KV.Registry','Elixir.KV.Supervisor']}]}.\n"
"```"
msgstr ""

msgid ""
"This file contains Erlang terms (written using Erlang syntax). Even though we "
"are not familiar with Erlang, it is easy to guess this file holds our applicat"
"ion definition. It contains our application `version`, all the modules defined"
" by it, as well as a list of applications we depend on, like Erlang's `kernel`"
", `elixir` itself, and `logger` which is specified in the `:extra_applications"
"` list in `mix.exs`."
msgstr ""

msgid ""
"It would be pretty boring to update this file manually every time we add a new"
" module to our application. That's why Mix generates and maintains it for us."
msgstr ""

msgid ""
"We can also configure the generated `.app` file by customizing the values retu"
"rned by the `application/0` inside our `mix.exs` project file. We are going to"
" do our first customization soon."
msgstr ""

msgid "### Starting applications"
msgstr ""

msgid ""
"When we define a `.app` file, which is the application specification, we are a"
"ble to start and stop the application as a whole. We haven't worried about thi"
"s so far for two reasons:"
msgstr ""

msgid "1. Mix automatically starts our current application for us"
msgstr ""

msgid ""
"2. Even if Mix didn't start our application for us, our application does not y"
"et do anything when it starts"
msgstr ""

msgid ""
"In any case, let's see how Mix starts the application for us. Let's start a pr"
"oject console with `iex -S mix` and try:"
msgstr ""

msgid ""
"```iex\n"
"iex> Application.start(:kv)\n"
"{:error, {:already_started, :kv}}\n"
"```"
msgstr ""

msgid ""
"Oops, it's already started. Mix normally starts the whole hierarchy of applica"
"tions defined in our project's `mix.exs` file and it does the same for all dep"
"endencies if they depend on other applications."
msgstr ""

msgid ""
"We can pass an option to Mix to ask it to not start our application. Let's giv"
"e it a try by running `iex -S mix run --no-start`:"
msgstr ""

msgid ""
"```iex\n"
"iex> Application.start(:kv)\n"
":ok\n"
"```"
msgstr ""

msgid ""
"We can stop our `:kv` application as well as the `:logger` application, which "
"is started by default with Elixir:"
msgstr ""

msgid ""
"```iex\n"
"iex> Application.stop(:kv)\n"
":ok\n"
"iex> Application.stop(:logger)\n"
":ok\n"
"```"
msgstr ""

msgid "And let's try to start our application again:"
msgstr ""

msgid ""
"```iex\n"
"iex> Application.start(:kv)\n"
"{:error, {:not_started, :logger}}\n"
"```"
msgstr ""

msgid ""
"Now we get an error because an application that `:kv` depends on (`:logger` in"
" this case) isn't started. We need to either start each application manually i"
"n the correct order or call `Application.ensure_all_started` as follows:"
msgstr ""

msgid ""
"```iex\n"
"iex> Application.ensure_all_started(:kv)\n"
"{:ok, [:logger, :kv]}\n"
"```"
msgstr ""

msgid ""
"Nothing really exciting happens but it shows how we can control our applicatio"
"n."
msgstr ""

msgid ""
"> When you run `iex -S mix`, it is equivalent to running `iex -S mix run`. So "
"whenever you need to pass more options to Mix when starting IEx, it's a matter"
" of typing `iex -S mix run` and then passing any options the `run` command acc"
"epts. You can find more information about `run` by running `mix help run` in y"
"our shell."
msgstr ""

msgid "### The application callback"
msgstr ""

msgid ""
"Since we spent all this time talking about how applications are started and st"
"opped, there must be a way to do something useful when the application starts."
" And indeed, there is!"
msgstr ""

msgid ""
"We can specify an application callback function. This is a function that will "
"be invoked when the application starts. The function must return a result of `"
"{:ok, pid}`, where `pid` is the process identifier of a supervisor process."
msgstr ""

msgid ""
"We can configure the application callback in two steps. First, open up the `mi"
"x.exs` file and change `def application` to the following:"
msgstr ""

msgid ""
"```elixir\n"
"  def application do\n"
"    [\n"
"      extra_applications: [:logger],\n"
"      mod: {KV, []}\n"
"    ]\n"
"  end\n"
"```"
msgstr ""

msgid ""
"The `:mod` option specifies the \"application callback module\", followed by the"
" arguments to be passed on application start. The application callback module "
"can be any module that implements the [Application](https://hexdocs.pm/elixir/"
"Application.html) behaviour."
msgstr ""

msgid ""
"Now that we have specified `KV` as the module callback, we need to change the "
"`KV` module, defined in `lib/kv.ex`:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule KV do\n"
"  use Application"
msgstr ""

msgid ""
"  def start(_type, _args) do\n"
"    KV.Supervisor.start_link(name: KV.Supervisor)\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid ""
"When we `use Application`, we need to define a couple functions, similar to wh"
"en we used `Supervisor` or `GenServer`. This time we only need to define a `st"
"art/2` function. If we wanted to specify custom behaviour on application stop,"
" we could define a `stop/1` function."
msgstr ""

msgid ""
"Let's start our project console once again with `iex -S mix`. We will see a pr"
"ocess named `KV.Registry` is already running:"
msgstr ""

msgid ""
"```iex\n"
"iex> KV.Registry.create(KV.Registry, \"shopping\")\n"
":ok\n"
"iex> KV.Registry.lookup(KV.Registry, \"shopping\")\n"
"{:ok, #PID<0.88.0>}\n"
"```"
msgstr ""

msgid ""
"How do we know this is working? After all, we are creating the bucket and then"
" looking it up; of course it should work, right? Well, remember that `KV.Regis"
"try.create/2` uses `GenServer.cast/2`, and therefore will return `:ok` regardl"
"ess of whether the message finds its target or not. At that point, we don't kn"
"ow whether the supervisor and the server are up, and if the bucket was created"
". However, `KV.Registry.lookup/2` uses `GenServer.call/3`, and will block and "
"wait for a response from the server. We do get a positive response, so we know"
" all is up and running."
msgstr ""

msgid ""
"For an experiment, try reimplementing `KV.Registry.create/2` to use `GenServer"
".call/3` instead, and momentarily disable the application callback. Run the co"
"de above on the console again, and you will see the creation step fail straigh"
"taway."
msgstr ""

msgid "Don't forget to bring the code back to normal before resuming this tutorial!"
msgstr ""

msgid "### Projects or applications?"
msgstr ""

msgid ""
"Mix makes a distinction between projects and applications. Based on the conten"
"ts of our `mix.exs` file, we would say we have a Mix project that defines the "
"`:kv` application. As we will see in later chapters, there are projects that d"
"on't define any application."
msgstr ""

msgid ""
"When we say \"project\" you should think about Mix. Mix is the tool that manages"
" your project. It knows how to compile your project, test your project and mor"
"e. It also knows how to compile and start the application relevant to your pro"
"ject."
msgstr ""

msgid ""
"When we talk about applications, we talk about  <abbr title=\"Open Telecom Plat"
"form\">OTP</abbr>. Applications are the entities that are started and stopped a"
"s a whole by the runtime. You can learn more about applications in the [docs f"
"or the Application module](https://hexdocs.pm/elixir/Application.html), as wel"
"l as by running `mix help compile.app` to learn more about the supported optio"
"ns in `def application`."
msgstr ""

msgid "## Simple one for one supervisors"
msgstr ""

msgid ""
"We have now successfully defined our supervisor which is automatically started"
" (and stopped) as part of our application lifecycle."
msgstr ""

msgid ""
"Remember however that our `KV.Registry` is both linking (via `start_link`) and"
" monitoring (via `monitor`) bucket processes in the `handle_cast/2` callback:"
msgstr ""

msgid ""
"```elixir\n"
"{:ok, pid} = KV.Bucket.start_link([])\n"
"ref = Process.monitor(pid)\n"
"```"
msgstr ""

msgid ""
"Links are bi-directional, which implies that a crash in a bucket will crash th"
"e registry. Although we now have the supervisor, which guarantees the registry"
" will be back up and running, crashing the registry still means we lose all da"
"ta associating bucket names to their respective processes."
msgstr ""

msgid ""
"In other words, we want the registry to keep on running even if a bucket crash"
"es. Let's write a new registry test:"
msgstr ""

msgid ""
"```elixir\n"
"test \"removes bucket on crash\", %{registry: registry} do\n"
"  KV.Registry.create(registry, \"shopping\")\n"
"  {:ok, bucket} = KV.Registry.lookup(registry, \"shopping\")"
msgstr ""

msgid ""
"  # Stop the bucket with non-normal reason\n"
"  Agent.stop(bucket, :shutdown)\n"
"  assert KV.Registry.lookup(registry, \"shopping\") == :error\n"
"end\n"
"```"
msgstr ""

msgid ""
"The test is similar to \"removes bucket on exit\" except that we are being a bit"
" more harsh by sending `:shutdown` as the exit reason instead of `:normal`. If"
" a process terminates with a reason different than `:normal`, all linked proce"
"sses receive an EXIT signal, causing the linked process to also terminate unle"
"ss they are trapping exits."
msgstr ""

msgid ""
"Since the bucket terminated, the registry went away with it, and our test fail"
"s when trying to `GenServer.call/3` it:"
msgstr ""

msgid ""
"```\n"
"  1) test removes bucket on crash (KV.RegistryTest)\n"
"     test/kv/registry_test.exs:26\n"
"     ** (exit) exited in: GenServer.call(#PID<0.148.0>, {:lookup, \"shopping\"},"
" 5000)\n"
"         ** (EXIT) no process: the process is not alive or there's no process "
"currently associated with the given name, possibly because its application isn"
"'t started\n"
"     code: assert KV.Registry.lookup(registry, \"shopping\") == :error\n"
"     stacktrace:\n"
"       (elixir) lib/gen_server.ex:770: GenServer.call/3\n"
"       test/kv/registry_test.exs:33: (test)\n"
"```"
msgstr ""

msgid ""
"We are going to solve this issue by defining a new supervisor that will spawn "
"and supervise all buckets. There is one supervisor strategy, called `:simple_o"
"ne_for_one`, that is the perfect fit for such situations: it allows us to spec"
"ify a worker template and supervise many children based on this template. With"
" this strategy, no workers are started during the supervisor initialization. I"
"nstead, a worker is started manually via the `Supervisor.start_child/2` functi"
"on."
msgstr ""

msgid ""
"Let's define our `KV.BucketSupervisor` in `lib/kv/bucket_supervisor.ex` as fol"
"lows:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule KV.BucketSupervisor do\n"
"  use Supervisor"
msgstr ""

msgid ""
"  # A simple module attribute that stores the supervisor name\n"
"  @name KV.BucketSupervisor"
msgstr ""

msgid ""
"  def start_link(_opts) do\n"
"    Supervisor.start_link(__MODULE__, :ok, name: @name)\n"
"  end"
msgstr ""

msgid ""
"  def start_bucket do\n"
"    Supervisor.start_child(@name, [])\n"
"  end"
msgstr ""

msgid ""
"  def init(:ok) do\n"
"    Supervisor.init([KV.Bucket], strategy: :simple_one_for_one)\n"
"  end\n"
"end\n"
"```"
msgstr ""

msgid "There are two changes in this supervisor compared to the first one."
msgstr ""

msgid ""
"First of all, we have decided to give the supervisor a local name of `KV.Bucke"
"tSupervisor`. While we could have passed the `opts` received on `start_link/1`"
" to the supervisor, we chose to hard code the name for simplicity. Note this a"
"pproach has downsides. For example, you wouldn't be able to start multiple ins"
"tances of the `KV.BucketSupervisor` during tests, as they would conflict on th"
"e name. In this case, we will just allow all registries to use the same bucket"
" supervisor at once, that won't be a problem since children of a simple one fo"
"r one supervisor don't interfere with one another."
msgstr ""

msgid ""
"We have also defined a `start_bucket/0` function that will start a bucket as a"
" child of our supervisor named `KV.BucketSupervisor`. `start_bucket/0` is the "
"function we are going to invoke instead of calling `KV.Bucket.start_link/1` di"
"rectly in the registry."
msgstr ""

msgid "Run `iex -S mix` so we can give our new supervisor a try:"
msgstr ""

msgid ""
"```iex\n"
"iex> {:ok, _} = KV.BucketSupervisor.start_link([])\n"
"{:ok, #PID<0.70.0>}\n"
"iex> {:ok, bucket} = KV.BucketSupervisor.start_bucket\n"
"{:ok, #PID<0.72.0>}\n"
"iex> KV.Bucket.put(bucket, \"eggs\", 3)\n"
":ok\n"
"iex> KV.Bucket.get(bucket, \"eggs\")\n"
"3\n"
"```"
msgstr ""

msgid ""
"We are almost ready to use the simple one for one supervisor in our applicatio"
"n. The first step is to change the registry to invoke `start_bucket`:"
msgstr ""

msgid ""
"```elixir\n"
"  def handle_cast({:create, name}, {names, refs}) do\n"
"    if Map.has_key?(names, name) do\n"
"      {:noreply, {names, refs}}\n"
"    else\n"
"      {:ok, pid} = KV.BucketSupervisor.start_bucket()\n"
"      ref = Process.monitor(pid)\n"
"      refs = Map.put(refs, ref, name)\n"
"      names = Map.put(names, name, pid)\n"
"      {:noreply, {names, refs}}\n"
"    end\n"
"  end\n"
"```"
msgstr ""

msgid ""
"The second step is to make sure `KV.BucketSupervisor` is started when our appl"
"ication boots. We can do this by opening `lib/kv/supervisor.ex` and changing `"
"init/1` to the following:"
msgstr ""

msgid ""
"```elixir\n"
"  def init(:ok) do\n"
"    children = [\n"
"      {KV.Registry, name: KV.Registry},\n"
"      KV.BucketSupervisor\n"
"    ]"
msgstr ""

msgid ""
"That's enough for our tests to pass but there is a resource leakage in our app"
"lication. When a bucket terminates, the supervisor will start a new bucket in "
"its place. After all, that's the role of the supervisor!"
msgstr ""

msgid ""
"However, when the supervisor restarts the new bucket, the registry does not kn"
"ow about it. So we will have an empty bucket in the supervisor that nobody can"
" access! To solve this, we want to say that buckets are actually temporary. If"
" they crash, regardless of the reason, they should not be restarted."
msgstr ""

msgid ""
"We can do this by passing the `restart: :temporary` option to `use Agent` in `"
"KV.Bucket`:"
msgstr ""

msgid ""
"```elixir\n"
"defmodule KV.Bucket do\n"
"  use Agent, restart: :temporary\n"
"```"
msgstr ""

msgid ""
"Let's also add a test to `test/kv/bucket_test.exs` that guarantees the bucket "
"is temporary:"
msgstr ""

msgid ""
"```elixir\n"
"  test \"are temporary workers\" do\n"
"    assert Supervisor.child_spec(KV.Bucket, []).restart == :temporary\n"
"  end\n"
"```"
msgstr ""

msgid ""
"Our test uses the `Supervisor.child_spec/2` function to retrieve the child spe"
"cification out of a module and then assert its restart value is `:temporary`. "
"At this point, you may be wondering why use a supervisor if it never restarts "
"its children. It happens that supervisors provide more than restarts, they are"
" also responsible to guarantee proper startup and shutdown, especially in case"
" of crashes in a supervision tree."
msgstr ""

msgid "## Supervision trees"
msgstr ""

msgid ""
"When we added `KV.BucketSupervisor` as a child of `KV.Supervisor`, we began to"
" have supervisors that supervise other supervisors, forming so-called \"supervi"
"sion trees\"."
msgstr ""

msgid ""
"Every time you add a new child to a supervisor, it is important to evaluate if"
" the supervisor strategy is correct as well as the order of child processes. I"
"n this case, we are using `:one_for_one` and the `KV.Registry` is started befo"
"re `KV.BucketSupervisor`."
msgstr ""

msgid ""
"One flaw that shows up right away is the ordering issue. Since `KV.Registry` i"
"nvokes `KV.BucketSupervisor`, then the `KV.BucketSupervisor` must be started b"
"efore `KV.Registry`. Otherwise it may happen that the registry attempts to rea"
"ch the bucket supervisor before it has started."
msgstr ""

msgid ""
"The second flaw is related to the supervision strategy. If `KV.Registry` dies,"
" all information linking `KV.Bucket` names to bucket processes is lost. Theref"
"ore the `KV.BucketSupervisor` and all children must terminate too - otherwise "
"we will have orphan processes."
msgstr ""

msgid ""
"In light of this observation, we should consider moving to another supervision"
" strategy. The two other candidates are `:one_for_all` and `:rest_for_one`. A "
"supervisor using the `:rest_for_one` will kill and restart child processes whi"
"ch were started *after* the crashed child. In this case, we would want `KV.Buc"
"ketSupervisor` to terminate if `KV.Bucket` terminates. This would require the "
"bucket supervisor to be placed after the registry. Which violates the ordering"
" constraints we have established two paragraphs above."
msgstr ""

msgid ""
"So our last option is to go all in and pick the `:one_for_all` strategy: the s"
"upervisor will kill and restart all of its children processes whenever any one"
" of them dies. This is a complete reasonable approach for our application, sin"
"ce the registry can't work without the bucket supervisor, and the bucket super"
"visor should terminate without the registry. Let's reimplement `init/1` in `KV"
".Supervisor` to encode those properties:"
msgstr ""

msgid ""
"```elixir\n"
"  def init(:ok) do\n"
"    children = [\n"
"      KV.BucketSupervisor,\n"
"      {KV.Registry, name: KV.Registry}\n"
"    ]"
msgstr ""

msgid ""
"    Supervisor.init(children, strategy: :one_for_all)\n"
"  end\n"
"```"
msgstr ""

msgid ""
"To help developers remember how to work with Supervisors and its convenience f"
"unctions, [Benjamin Tan Wei Hao](http://benjamintan.io/) has created a [Superv"
"isor cheat sheet](https://raw.githubusercontent.com/benjamintanweihao/elixir-c"
"heatsheets/master/Supervisor_CheatSheet.pdf)."
msgstr ""

msgid "There are two topics left before we move on to the next chapter."
msgstr ""

msgid "## Observer"
msgstr ""

msgid ""
"Now that we have defined our supervision tree, it is a great opportunity to in"
"troduce the Observer tool that ships with Erlang. Start your application with "
"`iex -S mix` and key this in:"
msgstr ""

msgid ""
"```iex\n"
"iex> :observer.start\n"
"```"
msgstr ""

msgid ""
"A GUI should pop-up containing all sorts of information about our system, from"
" general statistics to load charts as well as a list of all running processes "
"and applications."
msgstr ""

msgid ""
"In the Applications tab, you will see all applications currently running in yo"
"ur system along side their supervision tree. You can select the `kv` applicati"
"on to explore it further:"
msgstr ""

msgid ""
"<img src=\"/images/contents/kv-observer.png\" width=\"640\" alt=\"Observer GUI scre"
"enshot\" />"
msgstr ""

msgid ""
"Not only that, as you create new buckets on the terminal, you should see new p"
"rocesses spawned in the supervision tree shown in Observer:"
msgstr ""

msgid ""
"```iex\n"
"iex> KV.Registry.create KV.Registry, \"shopping\"\n"
":ok\n"
"```"
msgstr ""

msgid ""
"We will leave it up to you to further explore what Observer provides. Note you"
" can double click any process in the supervision tree to retrieve more informa"
"tion about it, as well as right-click a process to send \"a kill signal\", a per"
"fect way to emulate failures and see if your supervisor reacts as expected."
msgstr ""

msgid ""
"At the end of the day, tools like Observer is one of the main reasons you want"
" to always start processes inside supervision trees, even if they are temporar"
"y, to ensure they are always reachable and introspectable."
msgstr ""

msgid "## Shared state in tests"
msgstr ""

msgid ""
"So far we have been starting one registry per test to ensure they are isolated"
":"
msgstr ""

msgid ""
"```elixir\n"
"setup do\n"
"  {:ok, registry} = start_supervised(KV.Registry)\n"
"  %{registry: registry}\n"
"end\n"
"```"
msgstr ""

msgid ""
"Since we have now changed our registry to use `KV.BucketSupervisor`, which is "
"registered globally, our tests are now relying on this shared supervisor even "
"though each test has its own registry. The question is: should we?"
msgstr ""

msgid ""
"It depends. It is ok to rely on shared state as long as we depend only on a no"
"n-shared partition of this state. Although multiple registries may start bucke"
"ts on the shared bucket supervisor, those buckets and registries are isolated "
"from each other. We would only run into concurrency issues if we used a functi"
"on like `Supervisor.count_children(KV.Bucket.Supervisor)` which would count al"
"l buckets from all registries, potentially giving different results when tests"
" run concurrently."
msgstr ""

msgid ""
"Since we have relied only on a non-shared partition of the bucket supervisor s"
"o far, we don't need to worry about concurrency issues in our test suite. In c"
"ase it ever becomes a problem, we can start a supervisor per test and pass it "
"as an argument to the registry `start_link` function."
msgstr ""

msgid ""
"Now that our application is properly supervised and tested, let's see how we c"
"an speed things up."
msgstr ""
