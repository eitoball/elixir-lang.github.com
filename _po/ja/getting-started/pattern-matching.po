msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2019-05-28 06:00+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"layout: getting-started\n"
"title: Pattern matching\n"
"---"
msgstr ""
"---\n"
"layout: getting-started\n"
"title: パターン・マッチング\n"
"---"

msgid "# {{ page.title }}<span hidden>.</span>"
msgstr ""

msgid "{% include toc.html %}"
msgstr ""

msgid ""
"In this chapter, we will show how the `=` operator in Elixir is actually a mat"
"ch operator and how to use it to pattern match inside data structures. Finally"
", we will learn about the pin operator `^` used to access previously bound val"
"ues."
msgstr ""
"この章で私たちは、 Elixir における `=` 演算子が実際にマッチ演算子である事と、それをデータ構造の中でパターンマッチに使用する為の使い方を案内しま"
"す。終盤では、事前に指定された値へアクセスする為に使われるピン演算子 `^` について学びます。"

msgid "## The match operator"
msgstr "## マッチ演算子"

msgid "We have used the `=` operator a couple times to assign variables in Elixir:"
msgstr "私たちは、変数を定義する為に `=` 演算子を何度か使っています。"

msgid ""
"```iex\n"
"iex> x = 1\n"
"1\n"
"iex> x\n"
"1\n"
"```"
msgstr ""

msgid ""
"In Elixir, the `=` operator is actually called *the match operator*. Let's see"
" why:"
msgstr "Elixir では、実際のところ `=` 演算子は \"マッチ演算子\" と呼ばれます。その理由を見ていきましょう。"

msgid ""
"```iex\n"
"iex> 1 = x\n"
"1\n"
"iex> 2 = x\n"
"** (MatchError) no match of right hand side value: 1\n"
"```"
msgstr ""

msgid ""
"Notice that `1 = x` is a valid expression, and it matched because both the lef"
"t and right side are equal to 1. When the sides do not match, a `MatchError` i"
"s raised."
msgstr ""
"`1 = x` は有効な式であることに留意してください。さらに、左辺と右辺の両方が 1 に対して等しいのでマッチしています。その一方がマッチしない時は `M"
"atchError` が起こります。"

msgid "A variable can only be assigned on the left side of `=`:"
msgstr "変数は、それが `=` の左辺にある時だけ代入することができます。"

msgid ""
"```iex\n"
"iex> 1 = unknown\n"
"** (CompileError) iex:1: undefined function unknown/0\n"
"```"
msgstr ""

msgid ""
"Since there is no variable `unknown` previously defined, Elixir imagined you w"
"ere trying to call a function named `unknown/0`, but such a function does not "
"exist."
msgstr ""
"事前に定義された `unknown` という変数が存在しない以上、Elixir はあなたが `unknown/0` という関数の呼び出しを試みているものと考"
"えますが、そのような関数は存在していません。"

msgid "## Pattern matching"
msgstr "## パターン・マッチ"

msgid ""
"The match operator is not only used to match against simple values, but it is "
"also useful for destructuring more complex data types. For example, we can pat"
"tern match on tuples:"
msgstr "マッチ演算子は単純にマッチングする為だけのものではなく、より複雑なデータ型を解体する為にも便利なものです。例えば、タプルでパターンマッチを使えます。"

msgid ""
"```iex\n"
"iex> {a, b, c} = {:hello, \"world\", 42}\n"
"{:hello, \"world\", 42}\n"
"iex> a\n"
":hello\n"
"iex> b\n"
"\"world\"\n"
"```"
msgstr ""

msgid ""
"A pattern match will error if the sides can't be matched, for example if the t"
"uples have different sizes:"
msgstr "一方がマッチしないのならパターンマッチは失敗します。例えば、それはタプルが違うサイズである等という時に起こります。"

msgid ""
"```iex\n"
"iex> {a, b, c} = {:hello, \"world\"}\n"
"** (MatchError) no match of right hand side value: {:hello, \"world\"}\n"
"```"
msgstr ""

msgid "And also when comparing different types:"
msgstr "さらには異なる型を比較しようとすることでも起こります。"

msgid ""
"```iex\n"
"iex> {a, b, c} = [:hello, \"world\", 42]\n"
"** (MatchError) no match of right hand side value: [:hello, \"world\", 42]\n"
"```"
msgstr ""

msgid ""
"More interestingly, we can match on specific values. The example below asserts"
" that the left side will only match the right side when the right side is a tu"
"ple that starts with the atom `:ok`:"
msgstr ""
"もっと面白いことに、値を指定してパターンマッチを使うこともできます。以下の例では、右辺がタプルかつその最初の要素はアトムの `:ok` である時にだけ、左辺"
"が右辺とマッチすることを名言しています。"

msgid ""
"```iex\n"
"iex> {:ok, result} = {:ok, 13}\n"
"{:ok, 13}\n"
"iex> result\n"
"13"
msgstr ""

msgid ""
"iex> {:ok, result} = {:error, :oops}\n"
"** (MatchError) no match of right hand side value: {:error, :oops}\n"
"```"
msgstr ""

msgid "We can pattern match on lists:"
msgstr "リストでもパターンマッチは出来ます。"

msgid ""
"```iex\n"
"iex> [a, b, c] = [1, 2, 3]\n"
"[1, 2, 3]\n"
"iex> a\n"
"1\n"
"```"
msgstr ""

msgid "A list also supports matching on its own head and tail:"
msgstr "リストはそれ自身の首尾と後尾にマッチすることもサポートしています。"

msgid ""
"```iex\n"
"iex> [head | tail] = [1, 2, 3]\n"
"[1, 2, 3]\n"
"iex> head\n"
"1\n"
"iex> tail\n"
"[2, 3]\n"
"```"
msgstr ""

msgid ""
"Similar to the `hd/1` and `tl/1` functions, we can't match an empty list with "
"a head and tail pattern:"
msgstr "`hd/1` と `tl/1` 関数と同様に、首尾と後尾が空のリストにはマッチできません。"

msgid ""
"```iex\n"
"iex> [h | t] = []\n"
"** (MatchError) no match of right hand side value: []\n"
"```"
msgstr ""

msgid ""
"The `[head | tail]` format is not only used on pattern matching but also for p"
"repending items to a list:"
msgstr "`[head | tail]` 形式はパターンマッチだけで使われるものではなく、リストの先頭に値を付加することにも使えます。"

msgid ""
"```iex\n"
"iex> list = [1, 2, 3]\n"
"[1, 2, 3]\n"
"iex> [0 | list]\n"
"[0, 1, 2, 3]\n"
"```"
msgstr ""

msgid ""
"Pattern matching allows developers to easily destructure data types such as tu"
"ples and lists. As we will see in the following chapters, it is one of the fou"
"ndations of recursion in Elixir and applies to other types as well, like maps "
"and binaries."
msgstr ""
"パターンマッチは、開発者がタプルやリストのようなデータ構造を解体するのを容易にしてくれます。次章で見ていくことになるものとしては、Elixir における再起"
"処理の基礎と、マップやバイナリのようにそれを異なる型へ適用するというものもあります。"

msgid "## The pin operator"
msgstr "## ピン演算子"

msgid "Variables in Elixir can be rebound:"
msgstr "Elixir の変数は再代入ができます。"

msgid ""
"```iex\n"
"iex> x = 1\n"
"1\n"
"iex> x = 2\n"
"2\n"
"```"
msgstr ""

msgid ""
"Use the pin operator `^` when you want to pattern match against an existing va"
"riable's value rather than rebinding the variable:"
msgstr "既存の変数の値に対して、再代入せずにパターンマッチをしたい時にはピン演算子 `^` を使います。"

msgid ""
"```iex\n"
"iex> x = 1\n"
"1\n"
"iex> ^x = 2\n"
"** (MatchError) no match of right hand side value: 2\n"
"iex> {y, ^x} = {2, 1}\n"
"{2, 1}\n"
"iex> y\n"
"2\n"
"iex> {y, ^x} = {2, 2}\n"
"** (MatchError) no match of right hand side value: {2, 2}\n"
"```"
msgstr ""

msgid ""
"Because we have assigned the value of 1 to the variable x, this last example c"
"ould also have been written as:"
msgstr "上での変数 x には既に 1 という値が代入されています。"

msgid ""
"```\n"
"iex> {y, 1} = {2, 2}\n"
"** (MatchError) no match of right hand side value: {2, 2}\n"
"```"
msgstr ""

msgid ""
"If a variable is mentioned more than once in a pattern, all references should "
"bind to the same pattern:"
msgstr "一度のパターンに二つ以上の変数を書くと、参照する全てがパターンへの代入に成功することを期待します。"

msgid ""
"```iex\n"
"iex> {x, x} = {1, 1}\n"
"{1, 1}\n"
"iex> {x, x} = {1, 2}\n"
"** (MatchError) no match of right hand side value: {1, 2}\n"
"```"
msgstr ""

msgid ""
"In some cases, you don't care about a particular value in a pattern. It is a c"
"ommon practice to bind those values to the underscore, `_`. For example, if on"
"ly the head of the list matters to us, we can assign the tail to underscore:"
msgstr ""

msgid ""
"```iex\n"
"iex> [h | _] = [1, 2, 3]\n"
"[1, 2, 3]\n"
"iex> h\n"
"1\n"
"```"
msgstr ""

msgid ""
"The variable `_` is special in that it can never be read from. Trying to read "
"from it gives a compile error:"
msgstr ""

msgid ""
"```iex\n"
"iex> _\n"
"** (CompileError) iex:1: invalid use of _. \"_\" represents a value to be ignore"
"d in a pattern and cannot be used in expressions\n"
"```"
msgstr ""

msgid ""
"Although pattern matching allows us to build powerful constructs, its usage is"
" limited. For instance, you cannot make function calls on the left side of a m"
"atch. The following example is invalid:"
msgstr ""

msgid ""
"```iex\n"
"iex> length([1, [2], 3]) = 3\n"
"** (CompileError) iex:1: cannot invoke remote function :erlang.length/1 inside"
" match\n"
"```"
msgstr ""

msgid ""
"This finishes our introduction to pattern matching. As we will see in the next"
" chapter, pattern matching is very common in many language constructs."
msgstr ""
